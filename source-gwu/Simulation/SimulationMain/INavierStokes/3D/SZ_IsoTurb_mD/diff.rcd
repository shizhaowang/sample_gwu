Index: Simulation_initBlock.F90
===================================================================
--- Simulation_initBlock.F90	(revision 0)
+++ Simulation_initBlock.F90	(revision 0)
@@ -0,0 +1,415 @@
+!!****if* source/Simulation/SimulationMain/INavierStokes/3D/ChannelLam/Simulation_initBlock
+!!
+!! NAME
+!!
+!!  Simulation_initBlock
+!!
+!!
+!! SYNOPSIS
+!!
+!!  Simulation_initBlock(integer(in) :: blockID) 
+!!                       
+!!
+!!
+!!
+!! DESCRIPTION
+!!
+!!  Initializes fluid data (density, pressure, velocity, etc.) for
+!!  a specified block.
+!!
+!!  Reference:
+!!
+!! 
+!! ARGUMENTS
+!!
+!!  blockID -          the number of the block to update
+!!  myPE   -           my processor number
+!!
+!! 
+!!
+!!***
+
+!!#define LAMINAR_FLOW
+#define DOUBLE_GRID
+
+subroutine Simulation_initBlock(blockId)
+
+  use Simulation_data, ONLY : sim_xMin, sim_xMax, &
+                              sim_yMin, sim_yMax, &
+                              sim_zMin, sim_zMax, &
+                              sim_gCell, sim_fbao, sim_turbkin_expect
+
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkIndexLimits, &
+                             Grid_getCellCoords,     &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkBoundBox,    &
+                             Grid_getBlkCenterCoords
+
+  use Grid_data, only : gr_meshMe !,gr_axisComm,gr_axisMe,gr_axisNumProcs,gr_imax,gr_imin
+
+  use Driver_interface, only : Driver_abortFlash
+  
+  use RuntimeParameters_interface, only: RuntimeParameters_get
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+
+  !!$ Arguments -----------------------
+  integer, intent(in) :: blockID
+  !!$ ---------------------------------
+ 
+  integer :: i, j, k
+  integer, dimension(2,MDIM) :: blkLimits, blkLimitsGC
+  integer, dimension(MDIM) ::  blIndSize,blIndSizeGC
+
+  real, dimension(MDIM)  :: coord,bsize,del
+  real ::  boundBox(2,MDIM)
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+
+
+  integer :: nxvar,nyvar,nzvar,nxvar2,nyvar2,nzvar2,auxint,var
+  integer :: npt
+  real, allocatable, dimension(:)   :: xvar,yvar,zvar,aux
+  real, allocatable, dimension(:)   :: xcen,ycen,zcen
+  real, allocatable, dimension(:,:,:) :: Var0u,Var0v,Var0w
+  real, allocatable, dimension(:,:,:) :: Var0p,uab1,vab1,wab1
+
+  real :: texternal,qo,qold,dpdx
+
+  real :: dx,dy,dz
+  integer :: ix1,ix2,jy1,jy2,kz1,kz2
+
+  character(20) :: filename
+
+  real :: xedge(GRID_IHI_GC+1),xcell(GRID_IHI_GC)
+  real :: yedge(GRID_JHI_GC+1),ycell(GRID_JHI_GC)
+  real :: zedge(GRID_KHI_GC+1),zcell(GRID_KHI_GC)
+
+  real :: zp, fb
+
+  ! ISOTURB_UG_5PI_512
+  real, parameter :: ao = 0.04
+  real, parameter :: distb = 3.*PI/2.
+
+  ! ISOTURB_UG_4PI_TEST
+  !real, parameter :: ao = 0.1
+  !real, parameter :: distb = 6.*3.*PI/2. !OJO MADE IT NINE PI TO COVER ALL BOX
+
+  ! ISOTURB_UG_5PI_4OVER25_512
+  !real, parameter :: ao = 0.1*4./25. ! Rescale constant through (2pi)^2/(5pi)^2
+  !real, parameter :: distb = 3.*PI/2.
+
+  ! ISOTURB_UG_5PI_2OVER5_512
+  !real, parameter :: ao = 0.1*2./5. ! Rescale constant through (2pi)/(5pi)
+  !real, parameter :: distb = 3.*PI/2.
+
+
+  real, parameter :: distd = PI/2.
+
+  real, parameter :: zforcecen = 0.
+
+  !----------------------------------------------------------------------
+
+!  call RuntimeParameters_get('sim_fbao', sim_fbao)
+!  call RuntimeParameters_get('sim_turbkin_expect', sim_turbkin_expect)
+!  if(gr_meshMe == MASTER_PE) write(*,*) 'Forced turbulence, FBAO=', sim_fbao
+!  if(gr_meshMe == MASTER_PE) write(*,*) 'Expected tke =', sim_turbkin_expect
+
+  !if(gr_meshMe == MASTER_PE) write(*,*) 'Forced turbulence, ao=', ao
+
+  ! Get Coord and Bsize for the block:
+  ! Bounding box:
+  call Grid_getBlkBoundBox(blockId,boundBox)
+  bsize(:) = boundBox(2,:) - boundBox(1,:)
+
+  call Grid_getBlkCenterCoords(blockId,coord)
+
+  ! Get blocks dx, dy ,dz:
+  call Grid_getDeltas(blockID,del)
+
+  call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC,CENTER)
+
+  ! Compute Grid line locations:
+  ! Z:
+  do k=blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
+     zedge(k) = coord(KAXIS) - bsize(KAXIS)/2.0 + real(k - NGUARD - 1)*del(KAXIS)
+     zcell(k) = zedge(k) + 0.5*del(KAXIS)
+  enddo
+  zedge(blkLimitsGC(HIGH,KAXIS)+1)=coord(KAXIS)-bsize(KAXIS)/2.0 + &
+                                   real(blkLimitsGC(HIGH,KAXIS)-NGUARD)*del(KAXIS)
+  ! Y:
+  do j=blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
+     yedge(j) = coord(JAXIS) - bsize(JAXIS)/2.0 + real(j - NGUARD - 1)*del(JAXIS)
+     ycell(j) = yedge(j) + 0.5*del(JAXIS)
+  enddo
+  yedge(blkLimitsGC(HIGH,JAXIS)+1)=coord(JAXIS)-bsize(JAXIS)/2.0 + &
+                                   real(blkLimitsGC(HIGH,JAXIS)-NGUARD)*del(JAXIS)
+
+  ! X:
+  do i=blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
+     xedge(i) = coord(IAXIS) - bsize(IAXIS)/2.0 + real(i - NGUARD - 1)*del(IAXIS)
+     xcell(i) = xedge(i) + 0.5*del(IAXIS)
+  enddo
+  xedge(blkLimitsGC(HIGH,IAXIS)+1)=coord(IAXIS)-bsize(IAXIS)/2.0+ &
+                                   real(blkLimitsGC(HIGH,IAXIS)-NGUARD)*del(IAXIS)
+
+
+  ! Point to Blocks centered variables:
+  call Grid_getBlkPtr(blockID,solnData,CENTER)
+
+  ! Point to Blocks face variables: 
+  call Grid_getBlkPtr(blockID,facexData,FACEX)
+  call Grid_getBlkPtr(blockID,faceyData,FACEY)
+  call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+
+  ! Allocate arrays to read variable:
+  npt = 64
+  nxvar = npt+2
+  nyvar = npt+2
+  nzvar = npt+2
+
+  allocate(xvar(nxvar),yvar(nyvar),zvar(nzvar),aux(nzvar))
+  allocate(xcen(nxvar),ycen(nyvar),zcen(nzvar))
+  allocate(Var0u(nxvar,nyvar,nzvar), &
+           Var0v(nxvar,nyvar,nzvar), &
+           Var0w(nxvar,nyvar,nzvar), &
+           Var0p(nxvar,nyvar,nzvar), &
+           uab1(nxvar,nyvar,nzvar),  &
+           vab1(nxvar,nyvar,nzvar),  &
+           wab1(nxvar,nyvar,nzvar))
+
+  ! read grid:
+  OPEN(UNIT=2,FILE='./ICdata/64x64x64.grd',STATUS='OLD' )
+  read(2,111) ix1,ix2
+  read(2,111) jy1,jy2
+  read(2,111) kz1,kz2
+  read(2,112) dx,dy,dz
+
+  read(2,*) (xvar(i),i=ix1,ix2+1)
+  read(2,*) (aux(i) ,i=ix1,ix2+1)
+  read(2,*) (aux(i) ,i=ix1,ix2+1)
+  read(2,*) (aux(i) ,i=ix1,ix2+1)
+  read(2,*) (aux(i) ,i=ix1,ix2+1)
+  read(2,*) (aux(i) ,i=ix1,ix2+1)
+
+  read(2,*) (yvar(j),j=jy1,jy2+1)
+  read(2,*) (aux(j) ,j=jy1,jy2+1)
+  read(2,*) (aux(j) ,j=jy1,jy2+1)
+  read(2,*) (aux(j) ,j=jy1,jy2+1)
+  read(2,*) (aux(j) ,j=jy1,jy2+1)
+  read(2,*) (aux(j) ,j=jy1,jy2+1)
+
+  read(2,*) (zvar(k) ,k=kz1,kz2+1)
+  read(2,*) (aux(k),k=kz1,kz2+1)
+  read(2,*) (aux(k) ,k=kz1,kz2+1)
+  read(2,*) (aux(k) ,k=kz1,kz2+1)
+  read(2,*) (aux(k) ,k=kz1,kz2+1)
+  read(2,*) (aux(k) ,k=kz1,kz2+1)
+
+  close(2)
+
+  xvar(npt+1) = 2.*xvar(npt) - xvar(npt-1)
+  yvar(npt+1) = 2.*yvar(npt) - yvar(npt-1)
+  zvar(npt+1) = 2.*zvar(npt) - zvar(npt-1)
+
+  ! Compute cell centered coordinates:
+  do i = 2,ix2
+     xcen(i) = 0.5*(xvar(i)+xvar(i-1))
+  enddo
+  xcen(1) = xcen(2) - (xcen(3)-xcen(2))
+  xcen(nxvar) = xcen(nxvar-1) + (xcen(nxvar-1)-xcen(nxvar-2))
+
+  do j = 2,jy2
+     ycen(j) = 0.5*(yvar(j)+yvar(j-1))
+  enddo
+  ycen(1) = ycen(2) - (ycen(3)-ycen(2))
+  ycen(nyvar) = ycen(nyvar-1) + (ycen(nyvar-1)-ycen(nyvar-2))
+
+  do k = 2,kz2
+     zcen(k) = 0.5*(zvar(k)+zvar(k-1))
+  enddo
+  zcen(1) = zcen(2) - (zcen(3)-zcen(2))
+  zcen(nzvar) = zcen(nzvar-1) + (zcen(nzvar-1)-zcen(nzvar-2))
+
+  ! read restart file
+  open(19,file='./ICdata/64x64x64.res', status='unknown',form='unformatted')
+  read(19)  texternal
+  read(19)  qo,qold,dpdx
+  read(19)  Var0u,Var0v,Var0w,Var0p
+  read(19)  uab1,vab1,wab1
+  close(19)
+
+
+  ! Substract pi to match new box position:
+  xvar = xvar - 4.*atan(1.)
+  yvar = yvar - 4.*atan(1.)
+  zvar = zvar - 4.*atan(1.)
+
+  xcen = xcen - 4.*atan(1.)
+  ycen = ycen - 4.*atan(1.)
+  zcen = zcen - 4.*atan(1.)
+
+  call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC,FACEX)
+  ! Interpolate the variable to each point in the AMR grid
+  call interpvars_face(NGUARD,NXB,NYB,NZB, &
+                     coord,bsize,&
+                     nxvar,nyvar,nzvar,xvar,ycen,zcen,&
+                     Var0u,blkLimitsGC(HIGH,IAXIS),&
+                     blkLimitsGC(HIGH,JAXIS),&
+                     blkLimitsGC(HIGH,KAXIS),&
+                     facexData(VELC_FACE_VAR,:,:,:),1)
+
+
+  call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC,FACEY)
+  ! Interpolate the variable to each point in the AMR grid
+  call interpvars_face(NGUARD,NXB,NYB,NZB, &
+                     coord,bsize,&
+                     nxvar,nyvar,nzvar,xcen,yvar,zcen,&
+                     Var0v,blkLimitsGC(HIGH,IAXIS),&
+                     blkLimitsGC(HIGH,JAXIS),&
+                     blkLimitsGC(HIGH,KAXIS),&
+                     faceyData(VELC_FACE_VAR,:,:,:),2)
+
+
+  call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC,FACEZ)
+  ! Interpolate the variable to each point in the AMR grid
+  call interpvars_face(NGUARD,NXB,NYB,NZB,&
+                      coord,bsize,&
+                      nxvar,nyvar,nzvar,xcen,ycen,zvar,&
+                      Var0w,blkLimitsGC(HIGH,IAXIS),&
+                      blkLimitsGC(HIGH,JAXIS),&
+                      blkLimitsGC(HIGH,KAXIS),&
+                      facezData(VELC_FACE_VAR,:,:,:),3)
+
+
+  ! deallocation of auxiliary arrays exit
+  deallocate(xvar,yvar,zvar,aux)
+  deallocate(xcen,ycen,zcen)
+  deallocate(Var0u,Var0v,Var0w,Var0p)
+  deallocate(uab1,vab1,wab1)
+
+!  write(*,*) 'BlockID=',blockID
+!  write(*,*) 'Center coordinates=',coord
+!  write(*,*) 'Size =',bsize
+!  write(*,*) 'Uveloc, 2,2,2=', &
+!              facexData(VELC_FACE_VAR,NGUARD+1+2,NGUARD+2,NGUARD+2)
+!  write(*,*) 'Vveloc, 2,2,2=', &
+!              faceyData(VELC_FACE_VAR,NGUARD+2,NGUARD+1+2,NGUARD+2)
+!  write(*,*) 'Vveloc, 2,2,2=', &
+!              facezData(VELC_FACE_VAR,NGUARD+2,NGUARD+2,NGUARD+1+2)
+
+
+
+  solnData(PRES_VAR,:,:,:) = 0.0
+  solnData(DELP_VAR,:,:,:) = 0.0
+  solnData(DUST_VAR,:,:,:) = 0.0
+  solnData(TVIS_VAR,:,:,:) = 0.0
+
+  facexData(RHDS_FACE_VAR,:,:,:) = 0.0
+  faceyData(RHDS_FACE_VAR,:,:,:) = 0.0
+  facezData(RHDS_FACE_VAR,:,:,:) = 0.0
+
+  ! Set Force distribution Fb(x,y,z):
+  call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC,CENTER)
+  ! X velocity:
+  do k=blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
+     do j=blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
+        do i=blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)+1
+
+          zp = abs(zcell(k)-zforcecen) 
+
+          if (zp .le. distb) then
+             fb = 1.
+          elseif (zp .le. (distb+distd)) then
+             fb = 0.5*(1.-cos(PI/distd*(zp-distb-distd)))
+          else
+             fb = 0.
+          endif
+
+          !facexData(FBAO_FACE_VAR,i,j,k) = ao*fb
+          facexData(FBAO_FACE_VAR,i,j,k) = sim_fbao
+        enddo
+     enddo
+  enddo
+
+  do k=blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
+     do j=blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)+1
+        do i=blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
+
+          zp = abs(zcell(k)-zforcecen)
+
+          if (zp .le. distb) then
+             fb = 1.
+          elseif (zp .le. (distb+distd)) then
+             fb = 0.5*(1.-cos(PI/distd*(zp-distb-distd)))
+          else
+             fb = 0.
+          endif
+       
+          !faceyData(FBAO_FACE_VAR,i,j,k) = ao*fb         
+          faceyData(FBAO_FACE_VAR,i,j,k) = sim_fbao
+
+        enddo
+     enddo
+  enddo
+
+  ! Z velocity:
+  do k=blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)+1
+     do j=blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
+        do i=blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
+
+          zp = abs(zedge(k)-zforcecen)
+
+          if (zp .le. distb) then
+             fb = 1.
+          elseif (zp .le. (distb+distd)) then
+             fb = 0.5*(1.-cos(PI/distd*(zp-distb-distd)))
+          else
+             fb = 0.
+          endif
+
+          !facezData(FBAO_FACE_VAR,i,j,k) = ao*fb
+          facezData(FBAO_FACE_VAR,i,j,k) = sim_fbao
+
+        enddo
+     enddo
+  enddo
+
+
+  ! Divergence:
+  solnData(DUST_VAR,:,:,:) = 0.0
+  do k=blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
+     do j=blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
+        do i=blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
+          solnData(DUST_VAR,i,j,k) =(facexData(VELC_FACE_VAR,i+1,j,k)-facexData(VELC_FACE_VAR,i,j,k))/del(IAXIS)+&
+                                    (faceyData(VELC_FACE_VAR,i,j+1,k)-faceyData(VELC_FACE_VAR,i,j,k))/del(JAXIS)+&
+                                    (facezData(VELC_FACE_VAR,i,j,k+1)-facezData(VELC_FACE_VAR,i,j,k))/del(KAXIS)
+
+        enddo
+     enddo
+  enddo
+  if (gr_meshMe .eq. MASTER_PE)      write(*,*) 'Mype=',gr_meshMe,', min,maxdiv=', &
+  minval(solnData(DUST_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI)),&
+  maxval(solnData(DUST_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI))
+
+
+  ! Release pointer
+  call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+
+  call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+  call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+  call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+
+
+  return
+
+111    format (i4,3x,i4)
+112    format (3(3x,e12.4))
+
+
+end subroutine Simulation_initBlock
Index: IsoTurb_mD.sh
===================================================================
--- IsoTurb_mD.sh	(revision 0)
+++ IsoTurb_mD.sh	(revision 0)
@@ -0,0 +1 @@
+./setup INavierStokes/3D/wangsz/IsoTurb_mD -3d -auto +ug -nxb=128 -nyb=32 -nzb=32 -opt -objdir=ISOTURB PfftSolver=HomBcTrigSolver -site=colonialone.gwu.edu -noclobber

Property changes on: IsoTurb_mD.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: ins_substractmeanvel_z.F90
===================================================================
--- ins_substractmeanvel_z.F90	(revision 0)
+++ ins_substractmeanvel_z.F90	(revision 0)
@@ -0,0 +1,222 @@
+! subroutine ins_substractmeanvel_z
+! Substract mean velocity by slices on Z planes for turbulence simulations:
+! --------------------------------------------------------------------------
+
+#include "Flash.h"
+
+  subroutine ins_substractmeanvel_z(OUT_FACE_VAR,blockCount,blockList)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkCenterCoords,&
+                             Grid_getBlkPhysicalSize,&
+                             Grid_getBlkBoundBox,    &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits, &
+                             Grid_getBlkCornerID,    &
+                             Grid_getGlobalIndexLimits
+
+  
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get
+
+#ifdef FLASH_GRID_PARAMESH
+  use tree, ONLY : lrefine_max
+  use Grid_data, only : gr_meshMe, gr_meshNumProcs, gr_meshComm, gr_nblockZ
+#else
+  use Grid_data, only : gr_meshMe, gr_meshNumProcs, gr_meshComm
+#endif
+
+  use Driver_data, ONLY : dr_axisNumProcs
+
+  implicit none
+#include "constants.h"
+#include "Flash_mpi.h"
+#include "IncompNS.h"
+
+  integer :: OUT_FACE_VAR
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+  real, pointer, dimension(:,:,:,:) :: facexData,faceyData,facezData
+  
+  real :: del(MDIM),coord(MDIM),bsize(MDIM),boundBox(CONSTANT_TWO,MDIM),dx,dy,dz
+  real :: volcell
+
+  ! Total corners:
+  integer, save :: TotCorners 
+  integer, save, allocatable, dimension(:) :: CorIDList
+  real, save, allocatable, dimension(:)    :: volume, volumeaux
+  real, save, allocatable, dimension(:,:)  :: velmean, velmeanaux
+
+  integer iID,CorID,k,kk,lb,blockID,ierr
+
+  logical, save :: firstcall = .TRUE.
+
+  integer, dimension(MDIM) :: cornerID,stride
+
+  real, parameter :: eps = 1.e-12 
+
+
+  ! Number of corners on finer level:
+  if (firstcall) then
+#ifdef FLASH_GRID_PARAMESH
+    TotCorners = gr_nblockZ* 2**(lrefine_max-1) 
+#else /* Uniform grid */
+    TotCorners = dr_axisNumProcs(KAXIS)
+#endif
+
+    ! Allocate mean veloc variables:
+    allocate(CorIDList(TotCorners))
+    allocate(velmean(TotCorners*NZB,MDIM))
+    allocate( volume(TotCorners*NZB))
+    allocate(velmeanaux(TotCorners*NZB,MDIM))
+    allocate( volumeaux(TotCorners*NZB))
+
+
+    ! Populate corner ID list for all block sets in Z direction:
+    do iID = 1,TotCorners
+        CorIDList(iID) = (iID-1)*NZB + 1
+    enddo
+
+    firstcall = .false.
+    
+  endif
+
+  ! Compute meanU, meanV, meanW
+  velmean = 0.
+  volume  = 0.
+  do iID = 1,TotCorners
+
+    CorID = CorIDList(iID)
+
+    do lb = 1,blockCount
+
+        blockID = blockList(lb)
+ 
+        ! Block Corner ID
+        call Grid_getBlkCornerID(blockId, cornerID, stride)
+
+        if (cornerID(KAXIS) .ne. CorID) cycle  
+
+        ! Get blocks dx, dy ,dz:
+        call Grid_getDeltas(blockID,del)
+
+        ! Cell volume:
+        volcell = del(IAXIS)*del(JAXIS)*del(KAXIS) ! dx*dy*dz
+
+        ! Point to blocks center and face vars:
+        call Grid_getBlkPtr(blockID,facexData,FACEX)
+        call Grid_getBlkPtr(blockID,faceyData,FACEY)
+        call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+        ! Now loop in k:
+        kk = CorID - 1
+        do k = GRID_KLO , GRID_KHI
+
+          kk = kk + 1
+
+          ! U average:
+          velmean(kk,IAXIS) = velmean(kk,IAXIS) + &
+          sum(facexData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+          ! V average:
+          velmean(kk,JAXIS) = velmean(kk,JAXIS) + &
+          sum(faceyData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+          ! W average:
+          velmean(kk,KAXIS) = velmean(kk,KAXIS) + &
+          sum(facezData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+          ! Sum to processors total volume:
+          volume(kk) = volume(kk) + real(NXB*NYB*1)*volcell
+
+        enddo
+
+        ! Release pointers:
+        call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+        call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+        call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+        
+    enddo
+
+  enddo
+
+  ! Now all reduce:
+  velmeanaux = velmean
+  call MPI_Allreduce(velmeanaux, velmean, (TotCorners*NZB)*MDIM, FLASH_REAL,&
+                     MPI_SUM, gr_meshComm, ierr)
+  volumeaux  = volume
+  call MPI_Allreduce(volumeaux, volume, (TotCorners*NZB), FLASH_REAL,&
+                     MPI_SUM, gr_meshComm, ierr)  
+  
+  ! Do plane volume averages:
+  do iID = 1,TotCorners
+      do kk= (iID-1)*NZB+1 , iID*NZB
+
+         if (volume(kk) .lt. eps) then
+           write(*,*) ' '
+           write(*,*) 'Mype=',gr_meshMe,', slice kk=',kk
+           write(*,*) 'Plane Volume less than eps, vol=',volume(kk)
+           call Driver_abortFlash("Plane volume zero, this abort is to check single lref runs.") 
+         endif
+
+         velmean(kk,IAXIS:KAXIS) = velmean(kk,IAXIS:KAXIS)/volume(kk)
+
+      enddo
+  enddo  
+
+
+  ! Finally substract and assign:
+  do iID = 1,TotCorners
+
+    CorID = CorIDList(iID)
+
+    do lb = 1,blockCount
+
+        blockID = blockList(lb)
+ 
+        ! Block Corner ID
+        call Grid_getBlkCornerID(blockId, cornerID, stride)
+
+        if (cornerID(KAXIS) .ne. CorID) cycle
+
+        ! Point to blocks center and face vars:
+        call Grid_getBlkPtr(blockID,facexData,FACEX)
+        call Grid_getBlkPtr(blockID,faceyData,FACEY)
+        call Grid_getBlkPtr(blockID,facezData,FACEZ)
+ 
+        kk = CorID - 1
+        do k = GRID_KLO , GRID_KHI
+          kk = kk + 1
+
+          ! U vels:
+          facexData(OUT_FACE_VAR,GRID_ILO:GRID_IHI+1,GRID_JLO:GRID_JHI,k) = &
+          facexData(VELC_FACE_VAR,GRID_ILO:GRID_IHI+1,GRID_JLO:GRID_JHI,k) - velmean(kk,IAXIS)         
+
+          ! V vels:
+          faceyData(OUT_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI+1,k) = &
+          faceyData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI+1,k) - velmean(kk,JAXIS)
+          
+          ! W vels:
+          facezData(OUT_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) = &
+          facezData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) - velmean(kk,KAXIS)
+ 
+ 
+        enddo
+
+        ! Release pointers:
+        call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+        call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+        call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+
+    enddo
+
+  enddo
+
+  return
+  end subroutine
+
+
+
Index: ins_exportslices_z.F90
===================================================================
--- ins_exportslices_z.F90	(revision 0)
+++ ins_exportslices_z.F90	(revision 0)
@@ -0,0 +1,446 @@
+! subroutine ins_exportslices_z
+! Explorts slices on Z planes for turbulence simulations:
+! One file will be written per slice.
+! Values are exported at cell centers.
+! --------------------------------------------------------------------------
+
+  subroutine ins_exportslices_z(istep,iwrite,time,mvisc,blockCount,blockList)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkCenterCoords,&
+                             Grid_getBlkPhysicalSize,&
+                             Grid_getBlkBoundBox,    &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits, &
+                             Grid_getBlkCornerID,    &
+                             Grid_getGlobalIndexLimits
+
+  
+  use ins_interface, only  :  ins_velomg2center
+  
+  use Grid_data, only : gr_meshMe, gr_meshNumProcs, gr_meshComm, gr_imin, gr_imax, gr_jmin, gr_jmax
+  
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get
+
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "Flash_mpi.h"
+#include "IncompNS.h"
+
+  integer :: istep, iwrite
+  real    :: time, mvisc
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+  
+  real :: del(MDIM),coord(MDIM),bsize(MDIM),boundBox(CONSTANT_TWO,MDIM),dx,dy,dz
+  real :: volcell,tvol(MAXBLOCKS)
+
+  ! Variables on slices, function of z:
+
+!!$#ifdef COMPUTE_STATS
+!!$
+!!$  ! Index parameters:
+!!$  integer, parameter :: UAVG_IND  = 1
+!!$  integer, parameter :: VAVG_IND  = 2
+!!$  integer, parameter :: WAVG_IND  = 3
+!!$  integer, parameter :: OMGX2_IND = 4
+!!$  integer, parameter :: OMGY2_IND = 5
+!!$  integer, parameter :: OMGZ2_IND = 6 
+!!$  integer, parameter :: UU_IND    = 7
+!!$  integer, parameter :: VV_IND    = 8
+!!$  integer, parameter :: WW_IND    = 9
+!!$
+!!$  ! Plane Average squared vorticites vs. z:
+!!$  real :: omgx2(NZB,MAXBLOCKS),omgy2(NZB,MAXBLOCKS),omgz2(NZB,MAXBLOCKS)
+!!$  ! Plane average Reynolds stresses vs. z:
+!!$  real :: uu(NZB,MAXBLOCKS),vv(NZB,MAXBLOCKS),ww(NZB,MAXBLOCKS), &
+!!$          uv(NZB,MAXBLOCKS),uw(NZB,MAXBLOCKS),vw(NZB,MAXBLOCKS)
+!!$  ! Plane average q^2 -> TKE = 1/2 * q^2  vs. z:
+!!$  real :: q2(NZB,MAXBLOCKS)
+!!$  ! Plane average of rms fluctuations vs. z:
+!!$  real :: urms2(NZB,MAXBLOCKS),vrms2(NZB,MAXBLOCKS),wrms2(NZB,MAXBLOCKS)
+!!$  ! Plane average of longitudinal and transverse derivatives vs. z:
+!!$  real :: dudx2(NZB,MAXBLOCKS),dudy2(NZB,MAXBLOCKS)
+!!$  ! Plane average of longitudinal and transverse microscales vs. z:
+!!$  real :: lambdaf(NZB,MAXBLOCKS),lambdag(NZB,MAXBLOCKS)
+!!$  ! Plane average of dissipation vs. z:
+!!$  real :: eps_nu(NZB,MAXBLOCKS)
+!!$
+!!$  ! If LES
+!!$  ! Plane average of turbulent viscosity and SGS dissipation vs. z:
+!!$  real :: nut(NZB,MAXBLOCKS),eps_nut(NZB,MAXBLOCKS)
+!!$
+!!$  ! Average presssure field, and rms fluctuation:
+!!$  real :: pavg(NZB,MAXBLOCKS),prms2(NZB,MAXBLOCKS)
+!!$
+!!$  real :: dux,dvy,dwz,duy,duz,dvx,dvz,dwx,dwy
+!!$
+!!$
+!!$#else /* write out variables only */
+
+  ! Instantaneous field indexes
+  integer, parameter :: U_IND     = 1
+  integer, parameter :: V_IND     = 2
+  integer, parameter :: W_IND     = 3
+  
+  integer, parameter :: DUDX_IND  = 4    
+  integer, parameter :: DUDY_IND  = 5   
+  integer, parameter :: DUDZ_IND  = 6   
+  integer, parameter :: DVDX_IND  = 7    
+  integer, parameter :: DVDY_IND  = 8    
+  integer, parameter :: DVDZ_IND  = 9    
+  integer, parameter :: DWDX_IND  =10    
+  integer, parameter :: DWDY_IND  =11    
+  integer, parameter :: DWDZ_IND  =12   
+
+  integer, parameter :: PRES_IND  =13
+  integer, parameter :: TVIS_IND  =14
+
+  ! Here indexes for multiphase rhos, phi etc.
+
+
+  ! Total vars:
+  integer, parameter :: TotVars   =14
+
+!!$#endif
+
+  integer, save :: nslicez
+  real, save, allocatable, dimension(:) :: zc, Zslice
+  logical, save :: readfilez
+  real :: st_zmin,st_zmax
+
+  ! Maximum number of points in x and y for a slice:
+  integer, parameter :: NXBMAX = 386
+  integer, parameter :: NYBMAX = 386
+
+  ! Average velocities on each plane zc:
+  real, allocatable, dimension(:,:,:) :: data,dataaux
+
+  integer i,j,k,kk,lb,blockID,ierr
+
+  logical, save :: initfile  = .TRUE.
+  logical, save :: firstcall = .TRUE.
+
+  character(80) :: filename
+
+  integer, dimension(MDIM) :: globalIndexLimits,cornerID,stride,strideproc
+
+  real xedge(NXB+1),xcell(NXB+1)
+  real yedge(NYB+1),ycell(NYB+1)
+  real zedge(NZB+1),zcell(NZB+1)
+  real intsx(NXB+1), intsy(NYB+1), intsz(NZB+1)
+
+  integer :: icellz,istartx, istarty, ii, jj, slceproc, totslceproc, islicez
+
+  real :: Zslci, totzc
+  logical :: izc
+
+  real, parameter :: eps = 1.e-10 
+
+  !--- Initialize averages:
+  allocate(data(NXBMAX,NYBMAX,TotVars))
+  allocate(dataaux(NXBMAX,NYBMAX,TotVars))
+
+  ! Call filling of cell centered velocities and vorticity:
+  call ins_velomg2center(blockList,blockCount)
+
+
+  ! Load slice positions
+  if (firstcall) then
+
+     call RuntimeParameters_get("zmin", st_zmin)
+     call RuntimeParameters_get("zmax", st_zmax)
+
+    ! Z slices:
+     call RuntimeParameters_get("stats_nslicesz", nslicez)
+
+     !write(*,*) 'zmin max, nslicez=',st_zmin,st_zmin,nslicez
+
+     if (nslicez .gt. 0) then
+        allocate(Zslice(nslicez))
+        allocate(zc(nslicez))
+        call RuntimeParameters_get("stats_slicesz_from_file", readfilez)
+        if (readfilez) then
+           open(unit=33, file='./zlist_stats.slc', status='old')
+           do islicez = 1,nslicez
+              read(33,*) Zslice(islicez)
+           end do
+           close(33)
+        else
+           ! write evenly spaced across the domain:
+           dz = (st_zmax-st_zmin)/real(nslicez)
+           do islicez =1,nslicez
+              Zslice(islicez) = st_zmin + 0.5*dz + real(islicez-1)*dz
+           enddo
+        endif
+     endif
+
+     firstcall = .false.
+
+     !write(*,*) 'Zslice=',Zslice
+
+  endif
+
+
+  ! Now all processors compute and interpolate to the slice:
+  intsx    = (/ (real(i), i=0,NXB) /)
+  intsy    = (/ (real(i), i=0,NYB) /)
+  intsz    = (/ (real(i), i=0,NZB) /)
+
+
+  ! Loop over slices:
+  do islicez = 1 , nslicez
+
+     Zslci = Zslice(islicez)
+
+     zc(islicez)    = 0.
+     data = 0.
+     izc  = .true.
+     slceproc       = 0    
+     stride(1:MDIM) = 0
+
+     ! Loop over blocks:
+     do lb = 1,blockCount
+
+        blockID = blockList(lb)     
+
+        ! Bounding box:
+        call Grid_getBlkBoundBox(blockId,boundBox)
+
+        ! Test if slice falls on block domain
+        if (Zslci .gt. boundBox(2,KAXIS)) cycle
+        if (Zslci .le. boundBox(1,KAXIS)) cycle
+
+
+        ! Get blocks dx, dy ,dz, coord, bsize:
+        call Grid_getDeltas(blockID,del)
+        dx = del(IAXIS)
+        dy = del(JAXIS)
+        dz = del(KAXIS)
+
+        call Grid_getBlkCenterCoords(blockID,coord)
+
+        bsize(:) = boundBox(HIGH,:) - boundBox(LOW,:)
+
+        ! Cell, face locations:
+        xedge = coord(IAXIS) - bsize(IAXIS)/2.0 + dx*intsx;
+        xcell = xedge(:) + dx/2.0;
+
+        yedge = coord(JAXIS) - bsize(JAXIS)/2.0 + dy*intsy;
+        ycell = yedge(:) + dy/2.0;
+
+        zedge = coord(KAXIS) - bsize(KAXIS)/2.0 + dz*intsz;
+        zcell = zedge(:) + dz/2.0;
+
+
+        ! Interpolate values to slice location:
+        icellz = floor((Zslci - zedge(1))/dz) + 1
+        if (icellz .eq. (NZB+1)) icellz = icellz - 1
+
+        ! Linear interpolation factors
+        !intFactor_low  = (zedge(icellz+1)-Zslci)/dz
+        !intFactor_high = (Zslci - zedge(icellz))/dz
+        
+        ! Cell location in z:
+        if (izc) then 
+           zc(islicez) = zcell(icellz)         
+           izc         = .false.
+           slceproc    = 1
+        else
+           if (abs(zc(islicez)-zcell(icellz)) .gt. eps) then
+
+              write(*,*) ' '
+              write(*,*) 'MyPe=',gr_meshMe,', block',blockID,coord(:)
+              write(*,*) 'zc block=',zcell(icellz),', zc prev block=',zc(islicez)
+              write(*,*) 'Slice location=',Zslci 
+
+              call Driver_abortFlash("Z location for blocks on same slice is not the same.")
+
+           endif
+        endif
+
+        ! Point to blocks center and face vars:
+        call Grid_getBlkPtr(blockID,solnData,CENTER)
+        call Grid_getBlkPtr(blockID,facexData,FACEX)
+        call Grid_getBlkPtr(blockID,faceyData,FACEY)
+        call Grid_getBlkPtr(blockID,facezData,FACEZ)   
+
+        ! Block Corner ID
+        call Grid_getBlkCornerID(blockId, cornerID, stride)
+
+        ! Indexes for data in x, y:        
+        istartx = (cornerID(IAXIS)-1)/stride(IAXIS)
+        istarty = (cornerID(JAXIS)-1)/stride(JAXIS)
+
+        ! These are the index limits at maximum refinement: 
+        call Grid_getGlobalIndexLimits(globalIndexLimits)
+        if ( (istartx+NXB) .gt. NXBMAX) then
+             write(*,*) ' '
+             write(*,*) 'MyPe=',gr_meshMe,', block',blockID,', max ind X=',(istartx+NXB),NXBMAX
+             call Driver_abortFlash("Max index required for data greater than NXBMAX. Increase NXBMAX.")
+        endif
+        if ( (istarty+NYB) .gt. NYBMAX) then
+             write(*,*) ' '
+             write(*,*) 'MyPe=',gr_meshMe,', block',blockID,', max ind Y=',(istarty+NYB),NYBMAX
+             call Driver_abortFlash("Max index required for data greater than NYBMAX. Increase NYBMAX.")
+        endif
+
+        ! Compute variables, load to data:
+        jj = istarty
+        k  = icellz + NGUARD
+        do j = GRID_JLO , GRID_JHI
+          jj = jj + 1
+          ii = istartx
+          do i = GRID_ILO , GRID_IHI
+            ii = ii + 1
+    
+            ! Velocities: From the block face in the collocated direction to
+            ! the last internal face in that direction, that is shifted 1/2*del.
+            !data(ii,jj,U_IND) = facexData(VELC_FACE_VAR,i,j,k)
+
+            !data(ii,jj,V_IND) = faceyData(VELC_FACE_VAR,i,j,k)
+
+            !data(ii,jj,W_IND) = facezData(VELC_FACE_VAR,i,j,k)
+
+            ! Acerage to cell centers:
+            data(ii,jj,U_IND) = 0.5*(facexData(VELC_FACE_VAR,i,j,k)+facexData(VELC_FACE_VAR,i+1,j,k))
+
+            data(ii,jj,V_IND) = 0.5*(faceyData(VELC_FACE_VAR,i,j,k)+faceyData(VELC_FACE_VAR,i,j+1,k))
+
+            data(ii,jj,W_IND) = 0.5*(facezData(VELC_FACE_VAR,i,j,k)+facezData(VELC_FACE_VAR,i,j,k+1))
+            
+
+
+            ! Velocity derivatives:
+            data(ii,jj,DUDX_IND)=(facexData(VELC_FACE_VAR,i+1,j,k)-facexData(VELC_FACE_VAR,i,j,k))/del(IAXIS)
+            data(ii,jj,DVDY_IND)=(faceyData(VELC_FACE_VAR,i,j+1,k)-faceyData(VELC_FACE_VAR,i,j,k))/del(JAXIS)
+            data(ii,jj,DWDZ_IND)=(facezData(VELC_FACE_VAR,i,j,k+1)-facezData(VELC_FACE_VAR,i,j,k))/del(KAXIS)
+
+            data(ii,jj,DUDY_IND)=0.25*(facexData(VELC_FACE_VAR,i+1,j+1,k)-facexData(VELC_FACE_VAR,i+1,j-1,k) + &
+                                       facexData(VELC_FACE_VAR,i,j+1,k)  -facexData(VELC_FACE_VAR,i,j-1,k) )/del(JAXIS)
+            data(ii,jj,DUDZ_IND)=0.25*(facexData(VELC_FACE_VAR,i+1,j,k+1)-facexData(VELC_FACE_VAR,i+1,j,k-1) + &
+                                       facexData(VELC_FACE_VAR,i,j,k+1)  -facexData(VELC_FACE_VAR,i,j,k-1) )/del(KAXIS)
+
+            data(ii,jj,DVDX_IND)=0.25*(faceyData(VELC_FACE_VAR,i+1,j+1,k)-faceyData(VELC_FACE_VAR,i-1,j+1,k) + &  
+                                       faceyData(VELC_FACE_VAR,i+1,j,k)  -faceyData(VELC_FACE_VAR,i-1,j,k) )/del(IAXIS)
+            data(ii,jj,DVDZ_IND)=0.25*(faceyData(VELC_FACE_VAR,i,j+1,k+1)-faceyData(VELC_FACE_VAR,i,j+1,k-1) + &
+                                       faceyData(VELC_FACE_VAR,i,j,k+1)  -faceyData(VELC_FACE_VAR,i,j,k-1) )/del(KAXIS)
+            
+            data(ii,jj,DWDX_IND)=0.25*(facezData(VELC_FACE_VAR,i+1,j,k+1)-facezData(VELC_FACE_VAR,i-1,j,k+1) + &
+                                       facezData(VELC_FACE_VAR,i+1,j,k)  -facezData(VELC_FACE_VAR,i-1,j,k) )/del(IAXIS)
+            data(ii,jj,DWDY_IND)=0.25*(facezData(VELC_FACE_VAR,i,j+1,k+1)-facezData(VELC_FACE_VAR,i,j-1,k+1) + &
+                                       facezData(VELC_FACE_VAR,i,j+1,k)  -facezData(VELC_FACE_VAR,i,j-1,k) )/del(JAXIS)
+
+            data(ii,jj,PRES_IND)=solnData(PRES_VAR,i,j,k)
+
+            data(ii,jj,TVIS_IND)=solnData(TVIS_VAR,i,j,k)
+
+     
+          enddo
+        enddo
+
+     enddo ! loop blocks
+
+  
+     ! Allreduce zc location and test:     
+     ! First read number of processor that contain slice, and their zc(value)
+     call mpi_reduce(slceproc, totslceproc, 1, FLASH_INTEGER, MPI_SUM, MASTER_PE, gr_meshComm, ierr)
+     call mpi_reduce(zc(islicez), totzc, 1, FLASH_REAL, MPI_SUM, MASTER_PE, gr_meshComm, ierr)  
+
+     ! Now master tests location:
+     if (gr_meshME .eq. MASTER_PE) then
+
+        if (totslceproc .eq. 0) then
+           write(*,*) ' '
+           write(*,*) 'Tot number of procs that contain slice ',Zslci,'is zero.'
+     
+           call Driver_abortFlash("No processors contain slice location.")
+
+        endif
+       
+        totzc = totzc/real(totslceproc)
+
+        if ( real(slceproc)*abs(zc(islicez)-totzc) .gt. eps) then ! One of the slice locations doesn't match, abort:
+
+           write(*,*) ' '
+           write(*,*) 'MyPe=',gr_meshMe,', slice=',islicez
+           write(*,*) 'My zc=',zc(islicez),', doesnt match totzc=',totzc,slceproc
+
+           call Driver_abortFlash("Z location for slice is not the same on different processors.")
+
+        endif
+
+     endif
+
+     ! Compute the NXBtot, NYBtot:
+     ! Reduce max stride:
+     strideproc(1:MDIM) = stride(1:MDIM)
+     call mpi_reduce(strideproc, stride, MDIM, FLASH_INTEGER, MPI_MAX, MASTER_PE, gr_meshComm, ierr)
+
+     if (gr_meshME .eq. MASTER_PE) then
+
+        if (any(stride(1:MDIM) .eq. 0)) then
+
+           write(*,*) ' ' 
+           write(*,*) 'Zero stride=',stride(1:MDIM)
+
+           call Driver_abortFlash("Zero stride for slice, slice may be out of domain.")
+
+        endif 
+     
+        ! These are the index limits at maximum refinement: 
+        call Grid_getGlobalIndexLimits(globalIndexLimits)
+        ! These are the index limits at the slice refinement level (can be less than max,
+        ! but the same level has to be present for the whole slice):
+        globalIndexLimits(IAXIS) = globalIndexLimits(IAXIS)/stride(IAXIS)
+        globalIndexLimits(JAXIS) = globalIndexLimits(JAXIS)/stride(JAXIS)
+
+     endif
+
+     ! Now Brute force reduce data:
+     dataaux = data
+     call mpi_reduce(dataaux, data, NXBMAX*NYBMAX*TotVars, FLASH_REAL, MPI_SUM, MASTER_PE, gr_meshComm, ierr)
+
+
+     ! Master Processor Writes:
+     if (gr_meshME .eq. MASTER_PE) then
+
+        ! Slice name:
+        write(filename,'("./IOData/stat_slcz.",i4.4,".",i3.3,".bin")') &
+                        iwrite, islicez     
+
+        write(*,*) 'Writing filename=',trim(filename),totzc
+
+        open(1,file=trim(filename),status='replace',form='unformatted')
+
+        write(1) time,mvisc,totzc,Zslci
+        write(1) istep,globalIndexLimits(IAXIS),globalIndexLimits(JAXIS),TotVars
+        write(1) gr_imin,gr_imax,gr_jmin,gr_jmax
+
+        do k = 1, Totvars 
+
+           write(1) ( (data(i,j,k),i=1,globalIndexLimits(IAXIS)) , j=1,globalIndexLimits(JAXIS) )
+
+        enddo
+
+        close(1)
+
+     endif
+
+
+  enddo ! End do slices:
+
+
+  deallocate(data,dataaux)
+
+  return
+  end subroutine
+
+
+
Index: Driver_evolveFlash.F90
===================================================================
--- Driver_evolveFlash.F90	(revision 0)
+++ Driver_evolveFlash.F90	(revision 0)
@@ -0,0 +1,372 @@
+!!****if* source/Simulation/SimulationMain/INavierStokes/2D/LidDrivenCavity/Driver_evolveFlash
+!!
+!! NAME
+!!
+!!  Driver_evolveFlash
+!!
+!! SYNOPSIS
+!!
+!!  Driver_evolveFlash()
+!!
+!! DESCRIPTION
+!!
+!!  This is the main global driver for simulations that are:
+!!      Spatially refined, State form, strang split
+!!
+!!  DOC: Driver_evolveFlash needs more explanation 
+!!
+!! NOTES
+!!
+!!  variables that begin with "dr_" like, dr_globalMe or dr_dt, dr_beginStep
+!!  are stored in the data fortran module for the Driver unit, Driver_data.
+!!  The "dr_" is meant to indicate that the variable belongs to the Driver Unit.
+!!  all other normally named variables i, j, etc are local variables.
+!!
+!!
+!!***
+!!$#define DEDUG_ALL
+
+#define WRITE_TO_TECPLOT 1
+
+#ifdef DEBUG_ALL
+#define DEBUG_DRIVER
+#endif
+
+subroutine Driver_evolveFlash()
+
+  use Driver_data, ONLY: dr_globalMe, dr_nbegin,       &
+                         dr_nend, dr_dt, dr_wallClockTimeLimit, &
+                         dr_tmax, dr_simTime, dr_redshift,      &
+                         dr_nstep, dr_dtOld, dr_dtNew,          &
+                         dr_restart, dr_elapsedWCTime
+  use IncompNS_interface, ONLY : IncompNS
+  use Driver_interface, ONLY : Driver_sourceTerms, Driver_computeDt, &
+       Driver_getElapsedWCTime
+  use Logfile_interface,ONLY : Logfile_stamp, Logfile_close
+  use Timers_interface, ONLY : Timers_start, Timers_stop, &
+                               Timers_getSummary
+  use Particles_interface, ONLY : Particles_advance, Particles_dump
+
+  use Grid_interface, ONLY : Grid_getListOfBlocks,   &
+                             Grid_getDeltas,         &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits, &
+                             Grid_fillGuardCells,    &
+                             Grid_putFluxData,       &
+                             Grid_getFluxData,       &
+                             Grid_conserveFluxes,    &
+                             Grid_conserveField,     &
+                             Grid_solvePoisson, Grid_getBlkBoundBox, Grid_getBlkCenterCoords
+
+  use gr_interface, ONLY : gr_findMean
+
+
+  use Gravity_interface, ONLY :  Gravity_potentialListOfBlocks
+  use IO_interface,      ONLY : IO_output,IO_outputFinal
+
+  use Profiler_interface, ONLY : Profiler_start, Profiler_stop
+
+#ifdef WRITE_TO_TECPLOT
+  use IO_data , ONLY : io_plotFileNumber, IO_plotFileIntervalStep, IO_plotFileIntervalTime
+#endif
+
+  use ins_interface, only  :  ins_velomg2center, &
+                              ins_divergence, &
+                              ins_fluxfix,    &
+                              ins_fluxfix_p,  &
+                              ins_corrector
+
+  use IncompNS_data, only : ins_cflflg, ins_isgs, ins_invRe
+
+
+  use Grid_data, only : gr_meshMe,gr_meshComm
+
+  use IncompNSstats_interface, only : IncompNSstats
+
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+ include "Flash_mpi.h"
+
+  integer   :: localNumBlocks
+
+  integer :: blockCount
+  integer :: blockList(MAXBLOCKS)
+  integer :: sweepDummy
+  
+  ! for logfile output
+  character(len=MAX_STRING_LENGTH), dimension(3,2) :: strBuff
+  character(len=15) :: numToStr
+
+  logical :: endRun
+
+  logical :: tecplot_flg
+  integer count, firstfileflag
+ 
+  ! Turbulence simulation test case variables:
+  real :: turbkin
+  integer :: iso_nstatsz
+  integer :: istatsz = 0
+ 
+
+  endRun = .false.
+
+
+  call RuntimeParameters_get("nstatsz",iso_nstatsz)
+
+  call Logfile_stamp( 'Entering evolution loop' , '[Driver_evolveFlash]')
+  call Profiler_start("FLASH_evolution")
+  call Timers_start("evolution")
+
+  call Grid_getListOfBlocks(LEAF,blockList,blockCount)
+
+  ! Initial Timestep:
+  ! backup needed old
+  dr_dtOld = dr_dt
+
+  ! calculate new
+  call Driver_computeDt(dr_nbegin,  dr_nstep,      &
+                        dr_simTime, dr_dtOld, dr_dtNew)
+  ! store new
+  dr_dt = dr_dtNew
+
+  if (dr_globalMe == MASTER_PE) write(*,*) 'dr_dt ===',dr_dt
+
+  if(dr_restart) then
+     call ins_turbstats(dr_globalMe,dr_nstep,dr_simTime,&
+                        ins_invRe,blockCount,blockList,turbkin)
+  else
+  ! Substract mean velocities of initial field:
+  !call ins_substractmeanvel_z(VELC_FACE_VAR,blockCount,blockList)
+   call ins_substractmeanvel(dr_globalMe,dr_nstep,dr_simTime,&
+                              ins_invRe,blockCount,blockList)
+
+  ! Fill Guardcells for everything:
+  call Grid_fillGuardCells( CENTER_FACES, ALLDIR)
+  endif
+
+#ifdef WRITE_TO_TECPLOT
+  count = io_plotFileNumber-1
+  if (.not. dr_restart) then
+  firstfileflag = 0
+  dr_nstep = 0
+  count    = 0
+  call outtotecplot(dr_globalMe,dr_simtime,dr_dt,dr_nstep,count, &
+                    0.0,blockList,blockCount,firstfileflag)
+  endif
+  firstfileflag = 1
+#endif
+
+  ! Substract mean velocities of initial field:
+  !call ins_substractmeanvel(dr_globalMe,dr_nstep,dr_simTime,&
+  !                          ins_invRe,blockCount,blockList)
+
+
+  do dr_nstep = dr_nBegin, dr_nend
+     
+     !!Step forward in time. See bottom of loop for time step calculation.
+     call Grid_getLocalNumBlks(localNumBlocks)
+     call Grid_getListOfBlocks(LEAF,blockList,blockCount)
+     
+     if(mod(dr_nstep,iso_nstatsz)==0) then 
+     if (dr_globalMe == MASTER_PE) then
+
+        write (numToStr(1:), '(I10)') dr_nstep
+        write (strBuff(1,1), "(A)") "n"
+        write (strBuff(1,2), "(A)") trim(adjustl(numToStr))
+        
+        write (numToStr(1:), "(1PE12.6)") dr_simTime
+        write (strBuff(2,1), "(A)") "t"
+        write (strBuff(2,2), "(A)") trim(adjustl(numToStr))
+        
+        write (numToStr(1:), "(1PE12.6)") dr_dt
+        write (strBuff(3,1), "(A)") "dt"
+        write (strBuff(3,2), "(A)") trim(adjustl(NumToStr))
+        
+        call Logfile_stamp( strBuff, 3, 2, "step")
+     end if
+     endif
+
+     !--------------------------------------------------------------------
+     !- Start Physics Sequence
+     !----
+#ifdef DEBUG_DRIVER
+     print*, 'going into IncompNS'
+#endif
+     dr_simTime = dr_simTime + dr_dt
+
+     call Timers_start("IncompNS")
+     call IncompNS(blockCount, blockList,   &
+                   dr_simTime, dr_dt, dr_dtOld,  sweepDummy)
+     call Timers_stop("IncompNS")
+
+#ifdef DEBUG_DRIVER
+  print*, 'return from IncompNS timestep'
+#endif
+
+     call Timers_start("sourceTerms")
+     call Driver_sourceTerms(blockCount, blockList, dr_dt)
+     call Timers_stop("sourceTerms")
+#ifdef DEBUG_DRIVER
+     print*,'done source terms'
+     print*, 'return from Drivers_sourceTerms '
+#endif
+     call Timers_start("Particles_advance")
+     call Particles_advance(dr_dtOld, dr_dt)
+#ifdef DEBUG_DRIVER
+     print*, 'return from Particles_advance '
+#endif
+     call Timers_stop("Particles_advance")     
+     call Gravity_potentialListOfBlocks(blockCount,blockList)
+#ifdef DEBUG_DRIVER
+     print*, 'return from Gravity_potential '
+#endif
+
+     !----
+     !- End Physics Sequence
+     !--------------------------------------------------------------------
+
+!!$     call Timers_start("Grid_updateRefinement")
+!!$     call Grid_updateRefinement( dr_nstep, dr_simTime)
+!!$     call Timers_stop("Grid_updateRefinement")
+
+
+     ! Substract mean velocities:
+     !call ins_substractmeanvel(dr_globalMe,dr_nstep,dr_simTime,&
+     !                          ins_invRe,blockCount,blockList)
+
+     ! Substract mean velocities of initial field:
+     !call ins_substractmeanvel_z(VELC_FACE_VAR,blockCount,blockList)
+
+     ! Fill Guardcells for everything:
+     !call Grid_fillGuardCells( CENTER_FACES, ALLDIR)
+
+
+     !--------------------------------------------------------------------
+     ! Turbulent Statistics:
+     !-------------------------------------------------------------------
+     ! Compute Time averaged Statistics
+     call ins_turbstats(dr_globalMe,dr_nstep,dr_simTime,&
+                        ins_invRe,blockCount,blockList,turbkin)
+
+
+     if (MOD(dr_nstep,iso_nstatsz) .eq. 0) then
+       istatsz = istatsz + 1
+       !call ins_turbstats_z(dr_nstep,istatsz,dr_simTime,ins_invRe,blockCount,blockList)
+
+       !call ins_exportslices_z(dr_nstep,istatsz,dr_simTime,ins_invRe,blockCount,blockList)
+       call ins_exportBlock(dr_nstep,istatsz,dr_simTime,ins_invRe,blockCount,blockList)
+
+     endif
+
+     !--------------------------------------------------------------------
+
+
+     !----
+     !- Output results and plot files: 
+     !--------------------------------------------------------------------
+#ifdef WRITE_TO_TECPLOT 
+     ! Output to Tecplot
+     if (ins_cflflg .eq. 1) then ! Constant cfl       
+       if (dr_nstep .gt. 1) then
+       tecplot_flg = (1/IO_plotFileIntervalTime*MOD(dr_simtime,IO_plotFileIntervalTime) .le. &
+                      dr_dt/IO_plotFileIntervalTime)
+
+!       if (dr_globalMe .eq. MASTER_PE) write(*,*) 'tecplot_flg=',tecplot_flg,dr_dt,dr_simTime,IO_plotFileIntervalTime 
+
+       else
+       tecplot_flg = .false.
+       endif
+     else                        ! Constant timestep
+       tecplot_flg = (MOD(dr_nstep,IO_plotFileIntervalStep) .eq. 0)
+     endif 
+
+     if (tecplot_flg) then
+        ! Write to Grid to Tecplot:
+        count = count + 1      
+        call outtotecplot(dr_globalMe,dr_simtime,dr_dt,dr_nstep,count, &
+                          0.0,blockList,blockCount,firstfileflag)
+
+        if (count .gt. 0) firstfileflag = 1
+     endif
+#endif
+
+     ! Average Velocities and Vorticity to cell-centers
+     call ins_velomg2center(blocklist,blockcount) 
+
+     ! Flash Output Routine:
+     call Timers_start("io")
+     call IO_output(dr_simTime,dr_dt,dr_nstep+1,dr_nbegin,endRun)
+     call Timers_stop("io")
+
+
+
+     ! Compute Time averaged Statistics
+     call IncompNSstats()
+
+
+     !--------------------------------------------------------------------
+     if (dr_globalMe .eq. MASTER_PE) then
+        write(*,*) ' '        
+        write(*,'(I6,A,g16.8,A,g16.8)') dr_nstep,&
+                ', TimeStep= ',dr_dt,', SimTime= ', dr_simTime
+     endif     
+
+     if (dr_globalMe .eq. MASTER_PE) &
+     write(*,*) '###############################################################################'
+
+     ! Compute next step dt:
+     ! backup needed old
+     dr_dtOld = dr_dt
+
+     ! calculate new
+     call Driver_computeDt(dr_nbegin,  dr_nstep,      &
+                           dr_simTime, dr_dtOld, dr_dtNew)
+     ! store new
+     dr_dt = dr_dtNew
+
+     if(endRun) exit
+
+     !! the simulation ends before nend iterations if
+     !!  (i)   the simulation time is greater than the maximum time (tmax)
+     !!  (ii)  the redshift falls below the minimum redshift  
+     !!        (also called zfinal)
+     !!  (iii) the wall clock time is greater than the maximum 
+     !!        (wall_clock_time_max)
+
+     if (dr_simTime >= dr_tmax) then
+        if(dr_globalMe == MASTER_PE) then
+           print *, "exiting: reached max SimTime"
+        endif
+        exit
+     end if
+     
+     call Driver_getElapsedWCTime(dr_elapsedWCTime)
+     if (dr_elapsedWCTime >  dr_wallClockTimeLimit) then
+        if(dr_globalMe == MASTER_PE) then
+           print *, "exiting: reached max wall clock time"
+        endif
+        exit
+     end if
+
+  enddo
+
+  call Timers_stop("evolution")
+  call Profiler_stop("FLASH_evolution")
+  call Logfile_stamp( 'Exiting evolution loop' , '[Driver_evolveFlash]')
+  if(.NOT.endRun) call IO_outputFinal()
+  call Timers_getSummary(dr_nstep)
+  call Logfile_stamp( "FLASH run complete.", "LOGFILE_END")
+  call Logfile_close()
+
+  return
+  
+end subroutine Driver_evolveFlash
+
+
+
Index: Grid_markRefineDerefine.F90
===================================================================
--- Grid_markRefineDerefine.F90	(revision 0)
+++ Grid_markRefineDerefine.F90	(revision 0)
@@ -0,0 +1,172 @@
+!!****if* source/Grid/GridMain/paramesh/Grid_markRefineDerefine
+!!
+!! NAME
+!!  Grid_markRefineDerefine
+!!
+!! SYNOPSIS
+!!
+!!  Grid_markRefineDerefine()
+!!  
+!! DESCRIPTION 
+!!  Mark blocks for refinement or derefinement
+!!  This routine is used with AMR only where individual 
+!!  blocks are marked for refinement or derefinement based upon
+!!  some refinement criterion. The Uniform Grid does not need
+!!  this routine, and uses the stub.
+!!
+!! ARGUMENTS
+!! 
+!! NOTES
+!!
+!! Every unit uses a few unit scope variables that are
+!! accessible to all routines within the unit, but not to the
+!! routines outside the unit. For Grid unit these variables begin with "gr_"
+!! like, gr_meshMe or gr_eosMode, and are stored in fortran
+!! module Grid_data (in file Grid_data.F90). The other variables
+!! are local to the specific routines and do not have the prefix "gr_"
+!!
+!!
+!!***
+
+subroutine Grid_markRefineDerefine()
+
+
+#ifdef FLASH_GRID_PARAMESH
+
+  use Grid_data, ONLY : gr_refine_cutoff, gr_derefine_cutoff,&
+                        gr_refine_filter,&
+                        gr_numRefineVars,gr_refine_var,gr_refineOnParticleCount,&
+                        gr_enforceMaxRefinement, gr_maxRefine,&
+                        gr_lrefineMaxByTime,&
+                        gr_lrefineMaxRedDoByTime,&
+                        gr_lrefineMaxRedDoByLogR,&
+                        gr_lrefineCenterI,gr_lrefineCenterJ,gr_lrefineCenterK,&
+                        gr_eosModeNow
+  use tree, ONLY : newchild, refine, derefine, stay, lrefine_min
+!!$  use physicaldata, ONLY : force_consistency
+  use Logfile_interface, ONLY : Logfile_stampVarMask
+  use Grid_interface, ONLY : Grid_markRefineSpecialized,Grid_fillGuardCells
+  use Particles_interface, only: Particles_sinkMarkRefineDerefine
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+
+  
+  real :: ref_cut,deref_cut,ref_filter
+  integer       :: l,i,iref
+  logical,save :: gcMaskArgsLogged = .FALSE.
+  integer,save :: eosModeLast = 0
+  logical :: doEos=.true.
+  integer,parameter :: maskSize = NUNK_VARS+NDIM*NFACE_VARS
+  logical,dimension(maskSize) :: gcMask
+
+  !! Special refinement criteria -----------------
+  real, dimension(7) :: specs
+  integer :: lref,specsSize
+  !! End of special refinement treatment ---------
+
+
+  if(gr_lrefineMaxRedDoByTime) then
+     call gr_markDerefineByTime()
+  end if
+  
+  if(gr_lrefineMaxByTime) then
+     call gr_setMaxRefineByTime()
+  end if
+
+  if (gr_eosModeNow .NE. eosModeLast) then
+     gcMaskArgsLogged = .FALSE.
+     eosModeLast = gr_eosModeNow
+  end if
+
+  ! that are implemented in this file need values in guardcells
+
+  gcMask=.false.
+  do i = 1,gr_numRefineVars
+     iref = gr_refine_var(i)
+     if (iref > 0) gcMask(iref) = .TRUE.
+  end do
+
+  gcMask(NUNK_VARS+1:min(maskSize,NUNK_VARS+NDIM*NFACE_VARS)) = .TRUE.
+!!$  gcMask(NUNK_VARS+1:maskSize) = .TRUE.
+
+
+  if (.NOT.gcMaskArgsLogged) then
+     call Logfile_stampVarMask(gcMask, .true., '[Grid_markRefineDerefine]', 'gcArgs')
+  end if
+
+!!$  force_consistency = .FALSE.
+  call Grid_fillGuardCells(CENTER_FACES,ALLDIR,doEos=.true.,&
+       maskSize=maskSize, mask=gcMask, makeMaskConsistent=.true.,doLogMask=.NOT.gcMaskArgsLogged,&
+       selectBlockType=ACTIVE_BLKS)
+     gcMaskArgsLogged = .TRUE.
+!!$  force_consistency = .TRUE.
+
+  newchild(:) = .FALSE.
+  refine(:)   = .FALSE.
+  derefine(:) = .FALSE.
+  stay(:)     = .FALSE.
+
+  do l = 1,gr_numRefineVars
+     iref = gr_refine_var(l)
+     ref_cut = gr_refine_cutoff(l)
+     deref_cut = gr_derefine_cutoff(l)
+     ref_filter = gr_refine_filter(l)
+     call gr_markRefineDerefine(iref,ref_cut,deref_cut,ref_filter)
+  end do
+
+#ifdef FLASH_GRID_PARAMESH2
+  ! For PARAMESH2, call gr_markRefineDerefine here if it hasn't been called above.
+  ! This is necessary to make sure lrefine_min and lrefine_max are obeyed - KW
+  if (gr_numRefineVars .LE. 0) then
+     call gr_markRefineDerefine(-1, 0.0, 0.0, 0.0)
+  end if
+#endif
+
+!!#define SPECIAL_REFINEMENT 1
+
+#ifdef SPECIAL_REFINEMENT
+  !! Call for the specialized refinement
+  specsSize=7
+  !! Coordinate information --------------------------------------
+  !! define a range of coordinates of the rectangle in x-direction
+  specs(1) =  -12.5  + 0.005 ! sim_xMin + 0./4.*(sim_xMax - sim_xMin) +.005
+  specs(2) =   12.5  - 0.005 !sim_xMax -.005
+
+  !! define a range of coordinates of the rectangle in y-direction
+  specs(3) =  -12.5  + 0.005 !sim_yMin + 2./4.*(sim_yMax - sim_yMin) +.005
+  specs(4) =   12.5  - 0.005 !sim_yMin + 4./4.*(sim_yMax - sim_yMin) -.005
+
+  !! define a range of coordinates of the rectangle in z-direction
+  specs(5) =  -1.0  + 0.005 !sim_zMin + 1./4.*(sim_zMax - sim_zMin) +.05
+  specs(6) =   1.0  - 0.005 !sim_zMin + 3./4.*(sim_zMax - sim_zMin) -.05
+  !! End of coordinate information -------------------------------
+
+  !! Decide wheather or not we refine only blocks completely 
+  !! contained within the rectangle (specs(7) .NE. 0.0)
+  !! Otherwise, refine blocks with any overlap (specs(7) .EQ. 0.0)
+  specs(7) = 0.0
+
+  !! Bring all qualifying blocks to this level of refinement
+  lref = lrefine_min+1
+
+  call Grid_markRefineSpecialized (RECTANGLE,specsSize,specs,lref)
+#endif
+
+
+
+  if(gr_refineOnParticleCount)call gr_ptMarkRefineDerefine()
+
+  if(gr_enforceMaxRefinement) call gr_enforceMaxRefine(gr_maxRefine)
+
+  if(gr_lrefineMaxRedDoByLogR) &
+       call gr_unmarkRefineByLogRadius(gr_lrefineCenterI,&
+       gr_lrefineCenterJ,gr_lrefineCenterK)
+  
+  call Particles_sinkMarkRefineDerefine()
+#endif
+  
+  return
+end subroutine Grid_markRefineDerefine
+
Index: ins_substractmeanvel.F90
===================================================================
--- ins_substractmeanvel.F90	(revision 0)
+++ ins_substractmeanvel.F90	(revision 0)
@@ -0,0 +1,140 @@
+! --------------------------------------------------------------------------
+
+  subroutine ins_substractmeanvel(mype,istep,time,mvisc, &
+                                  blockCount,blockList)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits
+
+  use Grid_data, only : gr_meshMe
+      
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "IncompNS.h"
+  include 'mpif.h'
+
+  integer :: mype, istep
+  real :: time, mvisc
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+  integer, parameter ::  ng = NGUARD
+  integer, parameter ::  nxi= NGUARD + NXB
+  integer, parameter ::  nyj= NGUARD + NYB
+  integer, parameter ::  nzk= NGUARD + NZB
+  integer, parameter ::  nxc= NGUARD + NXB + 1
+  integer, parameter ::  nyc= NGUARD + NYB + 1
+  integer, parameter ::  nzc= NGUARD + NZB + 1
+
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+  
+  real del(3),dx,dy,dz
+  real turbkinaux,volcell,tvol,tvolaux
+  real varl,varlaux,vart,vartaux,dudx_v,dudy_v
+  real lambdaf,lambdag
+  real uavg,vavg,wavg,uavgaux,vavgaux,wavgaux,fconstn
+  real dissavg,dissavgaux
+
+  integer lb,blockID,ierr
+
+  ! -------------------------------------------------------------------
+  ! Average velocities, Check there is no drift:
+  uavg = 0.
+  vavg = 0.
+  wavg = 0.
+  tvol = 0.
+
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     ! Cell volume:
+     volcell = del(DIR_X)*del(DIR_Y)*del(DIR_Z) ! dx*dy*dz
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+     ! U average:
+     uavg = uavg + &
+      sum(facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk))*volcell
+
+     ! V average:
+     vavg = vavg + &
+      sum(faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk))*volcell
+
+     ! W average:
+     wavg = wavg + &
+      sum(facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc))*volcell
+
+     ! Sum to processors total volume:
+     tvol = tvol + real(NXB*NYB*NZB)*volcell
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+  
+
+  ! Sum processors average velocities:
+  uavgaux = uavg
+  call MPI_Allreduce(uavgaux, uavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+  vavgaux = vavg
+  call MPI_Allreduce(vavgaux, vavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+  wavgaux = wavg
+  call MPI_Allreduce(wavgaux, wavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+
+  ! Sum processors volumes
+  tvolaux = tvol  
+  call MPI_Allreduce(tvolaux, tvol, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr)
+
+
+  ! Average velocities:
+  uavg = uavg/tvol
+  vavg = vavg/tvol
+  wavg = wavg/tvol
+
+
+  ! Substract Mean Velocities: 
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     
+     facexData(VELC_FACE_VAR,:,:,:) = facexData(VELC_FACE_VAR,:,:,:) - uavg
+     faceyData(VELC_FACE_VAR,:,:,:) = faceyData(VELC_FACE_VAR,:,:,:) - vavg
+     facezData(VELC_FACE_VAR,:,:,:) = facezData(VELC_FACE_VAR,:,:,:) - wavg
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+
+  !if (gr_meshMe .eq. MASTER_PE) write(*,*) 'Average Velocities=',tvol,uavg,vavg,wavg
+
+  return
+  end subroutine
+
+
Index: ins_turbstats_z.F90
===================================================================
--- ins_turbstats_z.F90	(revision 0)
+++ ins_turbstats_z.F90	(revision 0)
@@ -0,0 +1,465 @@
+! subroutine ins_turbstats_z
+! Computes turbulent statistics on Z planes for turbulence simulations:
+! One file will be written per processor, the plane averages done on the
+! Processors portion of the plane.
+! This routine is intended for the domain in x and y to be completely owned
+! by the processor
+! Values are exported at cell centers.
+! --------------------------------------------------------------------------
+
+  subroutine ins_turbstats_z(istep,iwrite,time,mvisc,blockCount,blockList)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkCenterCoords,&
+                             Grid_getBlkPhysicalSize,&
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits
+
+  
+  use ins_interface, only  :  ins_velomg2center
+  
+  use Grid_data, only : gr_meshMe, gr_meshNumProcs
+  
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "IncompNS.h"
+  include 'mpif.h'
+
+  integer :: istep, iwrite
+  real    :: time, mvisc
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+!  integer, parameter ::  ng = NGUARD
+!  integer, parameter ::  nxi= NGUARD + NXB
+!  integer, parameter ::  nyj= NGUARD + NYB
+!  integer, parameter ::  nzk= NGUARD + NZB
+!  integer, parameter ::  nxc= NGUARD + NXB + 1
+!  integer, parameter ::  nyc= NGUARD + NYB + 1
+!  integer, parameter ::  nzc= NGUARD + NZB + 1
+
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+  
+  real :: del(MDIM),coord(MDIM),bsize(MDIM),dz !,dx,dy,dz
+  real :: volcell,tvol(MAXBLOCKS)
+
+  ! Variables to plane average and export, function of z:
+  ! Slice z Location:
+  real :: zc(NZB,MAXBLOCKS)
+  ! Average velocities on each plane vs. z:
+  real :: uavg(NZB,MAXBLOCKS),vavg(NZB,MAXBLOCKS),wavg(NZB,MAXBLOCKS)
+  ! Plane Average squared vorticites vs. z:
+  real :: omgx2(NZB,MAXBLOCKS),omgy2(NZB,MAXBLOCKS),omgz2(NZB,MAXBLOCKS)
+  ! Plane average Reynolds stresses vs. z:
+  real :: uu(NZB,MAXBLOCKS),vv(NZB,MAXBLOCKS),ww(NZB,MAXBLOCKS), &
+          uv(NZB,MAXBLOCKS),uw(NZB,MAXBLOCKS),vw(NZB,MAXBLOCKS)
+  ! Plane average q^2 -> TKE = 1/2 * q^2  vs. z:
+  real :: q2(NZB,MAXBLOCKS)
+  ! Plane average of rms fluctuations vs. z:
+  real :: urms2(NZB,MAXBLOCKS),vrms2(NZB,MAXBLOCKS),wrms2(NZB,MAXBLOCKS)
+  ! Plane average of longitudinal and transverse derivatives vs. z:
+  real :: dudx2(NZB,MAXBLOCKS),dudy2(NZB,MAXBLOCKS)
+  ! Plane average of longitudinal and transverse microscales vs. z:
+  real :: lambdaf(NZB,MAXBLOCKS),lambdag(NZB,MAXBLOCKS)
+  ! Plane average of dissipation vs. z:
+  real :: eps_nu(NZB,MAXBLOCKS)
+
+  ! If LES
+  ! Plane average of turbulent viscosity and SGS dissipation vs. z:
+  real :: nut(NZB,MAXBLOCKS),eps_nut(NZB,MAXBLOCKS)
+
+  ! Average presssure field, and rms fluctuation:
+  real :: pavg(NZB,MAXBLOCKS),prms2(NZB,MAXBLOCKS)
+
+  !,uavgaux,vavgaux,wavgaux,fconstn
+  !real dissavg,dissavgaux
+
+  real :: dux,dvy,dwz,duy,duz,dvx,dvz,dwx,dwy
+
+  integer i,j,k,kk,lb,blockID,ierr
+
+  logical, save :: initfile = .TRUE.
+
+  character(80) :: filename
+
+
+
+  !--- Initialize averages:
+  zc(:,:)   = 0.; 
+  uavg(:,:) = 0.; vavg(:,:) = 0.; wavg(:,:) = 0.;
+  omgx2(:,:) = 0.; omgy2(:,:) = 0.; omgz2(:,:) = 0.;
+
+  uu(:,:) = 0.; vv(:,:) = 0.; ww(:,:) = 0.; uv(:,:) = 0.; uw(:,:) = 0.; vw(:,:) = 0.;
+  q2(:,:) = 0.; urms2(:,:) = 0.; vrms2(:,:) = 0.; wrms2(:,:) = 0.;
+
+  dudx2(:,:) = 0.; dudy2(:,:) = 0.;
+  lambdaf(:,:) = 0.; lambdag(:,:) = 0.;
+
+  eps_nu(:,:) = 0.; 
+  nut(:,:)    = 0.; eps_nut(:,:) = 0.;
+  
+  pavg(:,:) = 0.; prms2(:,:) = 0.;
+
+  ! Call filling of cell centered velocities and vorticity:
+  call ins_velomg2center(blockList,blockCount)
+
+
+  ! Compute zc poisitions of cell centers:
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz, coord, bsize:
+     call Grid_getDeltas(blockID,del)
+     call Grid_getBlkCenterCoords(blockID,coord)
+     call Grid_getBlkPhysicalSize(blockID,bsize)
+  
+     dz = del(KAXIS)
+     ! cell center z locations for the block:
+     do k=1,NZB
+        zc(k,lb) = coord(KAXIS) - 0.5*bsize(KAXIS) + real(k-1)*dz + 0.5*dz 
+     enddo
+
+  enddo
+
+  ! For starters assume blockCount is 1, as in 
+  ! uniform grid, nprocs in z direction: 
+  ! -------------------------------------------------------------------
+  ! Average velocities in cell centers of plane:
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     ! Cell volume:
+     volcell = del(IAXIS)*del(JAXIS)*del(KAXIS)
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+     ! Now, by plane go to cell centers and add velocities:
+     kk =0
+     do k=GRID_KLO,GRID_KHI
+
+        kk = kk+1
+
+        ! U average:
+        uavg(kk,lb) = sum(solnData(VELX_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+        ! V average:
+        vavg(kk,lb) = sum(solnData(VELY_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+        ! W average:
+        wavg(kk,lb) = sum(solnData(VELZ_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+        ! Pres average:
+        pavg(kk,lb) = sum(solnData(PRES_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell
+
+        do j=GRID_JLO,GRID_JHI
+         do i=GRID_ILO,GRID_IHI
+
+            ! Omgx2 average:
+            omgx2(kk,lb) = omgx2(kk,lb) + solnData(OMGX_VAR,i,j,k)**2. * volcell                   
+
+            ! Omgy2 average:
+            omgy2(kk,lb) = omgy2(kk,lb) + solnData(OMGY_VAR,i,j,k)**2. * volcell
+
+            ! Omgz2 average:
+            omgz2(kk,lb) = omgz2(kk,lb) + solnData(OMGZ_VAR,i,j,k)**2. * volcell
+
+            ! Velocity products:
+            ! uu:
+            uu(kk,lb) = uu(kk,lb) + solnData(VELX_VAR,i,j,k)*solnData(VELX_VAR,i,j,k)*volcell
+            ! vv:
+            vv(kk,lb) = vv(kk,lb) + solnData(VELY_VAR,i,j,k)*solnData(VELY_VAR,i,j,k)*volcell
+            ! ww:
+            ww(kk,lb) = ww(kk,lb) + solnData(VELZ_VAR,i,j,k)*solnData(VELZ_VAR,i,j,k)*volcell
+            ! uv:
+            uv(kk,lb) = uv(kk,lb) + solnData(VELX_VAR,i,j,k)*solnData(VELY_VAR,i,j,k)*volcell
+            ! uw:
+            uw(kk,lb) = uw(kk,lb) + solnData(VELX_VAR,i,j,k)*solnData(VELZ_VAR,i,j,k)*volcell 
+            ! vw:
+            vw(kk,lb) = vw(kk,lb) + solnData(VELY_VAR,i,j,k)*solnData(VELZ_VAR,i,j,k)*volcell
+
+            ! Pressure product:
+            prms2(kk,lb) = prms2(kk,lb) + solnData(PRES_VAR,i,j,k)*solnData(PRES_VAR,i,j,k)*volcell
+
+            ! Longitudinal derivatives:
+            dux = (facexData(VELC_FACE_VAR,i+1,j,k) - facexData(VELC_FACE_VAR,i,j,k))/del(IAXIS)
+            dvy = (faceyData(VELC_FACE_VAR,i,j+1,k) - faceyData(VELC_FACE_VAR,i,j,k))/del(JAXIS) 
+            dwz = (facezData(VELC_FACE_VAR,i,j,k+1) - facezData(VELC_FACE_VAR,i,j,k))/del(KAXIS)
+
+            dudx2(kk,lb) = dudx2(kk,lb) + (dux**2. + dvy**2. + dwz**2.)*volcell
+
+            ! Transverse derivatives:
+            duy = 0.25*(facexData(VELC_FACE_VAR,i+1,j+1,k) - facexData(VELC_FACE_VAR,i+1,j-1,k) + &
+                        facexData(VELC_FACE_VAR,i,j+1,k)   - facexData(VELC_FACE_VAR,i,j-1,k) )/del(JAXIS)
+            duz = 0.25*(facexData(VELC_FACE_VAR,i+1,j,k+1) - facexData(VELC_FACE_VAR,i+1,j,k-1) + &
+                        facexData(VELC_FACE_VAR,i,j,k+1)   - facexData(VELC_FACE_VAR,i,j,k-1) )/del(KAXIS)
+
+            dvx = 0.25*(faceyData(VELC_FACE_VAR,i+1,j+1,k) - faceyData(VELC_FACE_VAR,i-1,j+1,k) + &  
+                        faceyData(VELC_FACE_VAR,i+1,j,k)   - faceyData(VELC_FACE_VAR,i-1,j,k) )/del(IAXIS)
+            dvz = 0.25*(faceyData(VELC_FACE_VAR,i,j+1,k+1) - faceyData(VELC_FACE_VAR,i,j+1,k-1) + &
+                        faceyData(VELC_FACE_VAR,i,j,k+1)   - faceyData(VELC_FACE_VAR,i,j,k-1) )/del(KAXIS)
+            
+            dwx = 0.25*(facezData(VELC_FACE_VAR,i+1,j,k+1) - facezData(VELC_FACE_VAR,i-1,j,k+1) + &
+                        facezData(VELC_FACE_VAR,i+1,j,k)   - facezData(VELC_FACE_VAR,i-1,j,k) )/del(IAXIS)
+            dwy = 0.25*(facezData(VELC_FACE_VAR,i,j+1,k+1) - facezData(VELC_FACE_VAR,i,j-1,k+1) + &
+                        facezData(VELC_FACE_VAR,i,j+1,k)   - facezData(VELC_FACE_VAR,i,j-1,k) )/del(JAXIS)
+
+            dudy2(kk,lb) = dudy2(kk,lb) + (duy**2. +duz**2. +dvx**2. +dvz**2. +dwx**2. +dwy**2.)*volcell 
+
+         enddo
+        enddo
+
+        ! nut average:
+        nut(kk,lb) = sum(solnData(TVIS_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k))*volcell 
+
+     enddo
+
+     ! Sum to blocks Plane total volume:
+     tvol(lb) = real(NXB*NYB*1)*volcell
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+  
+  ! Here information among processors and blocks containing the plane
+  ! should be gathered
+
+  ! Sum processors average velocities:
+  !uavgaux = uavg
+  !call MPI_Allreduce(uavgaux, uavg, 1, MPI_DOUBLE_PRECISION,&
+  !                   MPI_SUM, MPI_COMM_WORLD, ierr) 
+  !vavgaux = vavg
+  !call MPI_Allreduce(vavgaux, vavg, 1, MPI_DOUBLE_PRECISION,&
+  !                   MPI_SUM, MPI_COMM_WORLD, ierr) 
+  !wavgaux = wavg
+  !call MPI_Allreduce(wavgaux, wavg, 1, MPI_DOUBLE_PRECISION,&
+  !                   MPI_SUM, MPI_COMM_WORLD, ierr) 
+  ! Sum processors volumes
+  !tvolaux = tvol  
+  !call MPI_Allreduce(tvolaux, tvol, 1, MPI_DOUBLE_PRECISION,&
+  !                   MPI_SUM, MPI_COMM_WORLD, ierr)
+
+
+  ! Averages in the planes, per block:
+  do lb = 1,blockCount
+
+     ! Velocities:
+     uavg(:,lb) = uavg(:,lb)/tvol(lb)
+     vavg(:,lb) = vavg(:,lb)/tvol(lb)
+     wavg(:,lb) = wavg(:,lb)/tvol(lb)
+
+     ! Pressure:
+     pavg(:,lb) = pavg(:,lb)/tvol(lb)
+
+     ! Vorticity: 
+     omgx2(:,lb) = omgx2(:,lb)/tvol(lb)
+     omgy2(:,lb) = omgy2(:,lb)/tvol(lb)
+     omgz2(:,lb) = omgz2(:,lb)/tvol(lb)
+
+     ! Longitudinal and transverse derivatives dudx2 and dudy2
+     dudx2(:,lb) = dudx2(:,lb)/tvol(lb)
+     dudy2(:,lb) = dudy2(:,lb)/tvol(lb)
+
+     ! Turbulent viscosity:
+     nut(:,lb) = nut(:,lb)/tvol(lb)
+
+  enddo
+
+ 
+  ! Write up an average velocities file
+  if (gr_meshMe .eq. gr_meshNumProcs/2) then
+
+      if (initfile) then
+         OPEN(UNIT=240,FILE='./IOData/AVGVELS_z.res',STATUS='REPLACE', &
+              FORM='formatted')
+         write(240,'(I8,4g14.6)')istep,time,sum(uavg(1:NZB,1))/real(NZB), &
+                                            sum(vavg(1:NZB,1))/real(NZB), &
+                                            sum(wavg(1:NZB,1))/real(NZB)
+         close(240)
+         initfile = .false. 
+      else
+         OPEN(UNIT=240,FILE='./IOData/AVGVELS_z.res',STATUS='OLD',     &
+              FORM='formatted',POSITION='APPEND')
+         write(240,'(I8,4g14.6)')istep,time,sum(uavg(1:NZB,1))/real(NZB), &
+                                            sum(vavg(1:NZB,1))/real(NZB), &
+                                            sum(wavg(1:NZB,1))/real(NZB)
+         close(240)
+      endif
+
+   endif
+
+
+  ! Keep computing:
+  ! Now urms2 and q2:
+  ! Substract Mean Velocities, pressure: 
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+
+
+     ! Reynolds Stresses:
+     kk =0
+     do k=GRID_KLO,GRID_KHI
+        kk = kk+1
+
+        uu(kk,lb) = uu(kk,lb)/tvol(lb) - uavg(kk,lb)*uavg(kk,lb)
+        vv(kk,lb) = vv(kk,lb)/tvol(lb) - vavg(kk,lb)*vavg(kk,lb)
+        ww(kk,lb) = ww(kk,lb)/tvol(lb) - wavg(kk,lb)*wavg(kk,lb)
+
+        uv(kk,lb) = uv(kk,lb)/tvol(lb) - uavg(kk,lb)*vavg(kk,lb)
+        uw(kk,lb) = uw(kk,lb)/tvol(lb) - uavg(kk,lb)*wavg(kk,lb)
+        vw(kk,lb) = vw(kk,lb)/tvol(lb) - vavg(kk,lb)*wavg(kk,lb)
+
+        prms2(kk,lb) = prms2(kk,lb)/tvol(lb) - pavg(kk,lb)*pavg(kk,lb)
+
+     enddo
+
+     ! Now, get velocity fluctuations:
+     kk =0
+     do k=GRID_KLO,GRID_KHI
+
+        kk = kk+1
+      
+        ! u fluctuation:
+        solnData(VELX_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) = &
+        solnData(VELX_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) - uavg(kk,lb)       
+
+        ! v fluctuation:
+        solnData(VELY_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) = &
+        solnData(VELY_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) - vavg(kk,lb)
+        
+        ! w fluctuation:
+        solnData(VELZ_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) = &
+        solnData(VELZ_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,k) - wavg(kk,lb)
+
+        ! Rms2:
+        do j=GRID_JLO,GRID_JHI
+         do i=GRID_ILO,GRID_IHI
+
+            ! urms2:
+            urms2(kk,lb) = urms2(kk,lb) + solnData(VELX_VAR,i,j,k)*solnData(VELX_VAR,i,j,k)*volcell  
+
+            ! vrms2:
+            vrms2(kk,lb) = vrms2(kk,lb) + solnData(VELY_VAR,i,j,k)*solnData(VELY_VAR,i,j,k)*volcell 
+
+            ! wrms2:
+            wrms2(kk,lb) = wrms2(kk,lb) + solnData(VELZ_VAR,i,j,k)*solnData(VELZ_VAR,i,j,k)*volcell
+
+         enddo 
+        enddo
+
+        ! divide urms2, vrms2, wrms2 by tvol:
+        urms2(kk,lb) = urms2(kk,lb)/tvol(lb)
+        vrms2(kk,lb) = vrms2(kk,lb)/tvol(lb)
+        wrms2(kk,lb) = wrms2(kk,lb)/tvol(lb)
+
+        ! Get q^2:
+        q2(kk,lb) = urms2(kk,lb) + vrms2(kk,lb) + wrms2(kk,lb)
+
+     enddo
+
+     ! Resolved dissipation:
+     eps_nu(:,lb) = mvisc*(dudx2(:,lb) + dudy2(:,lb)) 
+
+
+     ! Finally Taylor microscales:
+     kk =0
+     do k=GRID_KLO,GRID_KHI
+
+        kk = kk+1
+
+        ! Longitudinal Lf = sqrt(2/3 * q2 / (1/3 dudx2))
+        lambdaf(kk,lb) = sqrt(2./3. * q2(kk,lb) / (1./3. * dudx2(kk,lb)))
+     
+        ! Transversal  Lg = sqrt(2/3 * q2 / (1/6 dudy2)) 
+        lambdag(kk,lb) = sqrt(2./3. * q2(kk,lb) / (1./6. * dudy2(kk,lb)))
+
+     enddo
+   
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+           
+  enddo
+
+  ! -------------------------------------------------------------------
+  ! Write Processor file:
+  write(filename,'("IOData/statsz.",i4.4,".",i4.4,".bin")') iwrite, gr_meshMe
+  if (gr_meshMe .eq. MASTER_PE) then 
+    write(*,*) ' '
+    write(*,*) 'Writing filename=',trim(filename)
+  endif
+  open(unit=1,file=trim(filename),status='replace',form='unformatted')
+  write(1) time
+  write(1) istep,blockCount,NXB,NYB,NZB  
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+     
+     ! Get blocks dx, dy ,dz, coord, bsize:
+     call Grid_getDeltas(blockID,del)
+     call Grid_getBlkCenterCoords(blockID,coord)
+     call Grid_getBlkPhysicalSize(blockID,bsize)
+     
+     ! Write out deltas, coord, bsize:
+     write(1) (del(i)  , i=1,MDIM)
+     write(1) (coord(i), i=1,MDIM)
+     write(1) (bsize(i), i=1,MDIM)
+
+     ! Write slices zc location:
+     write(1) (zc(kk,lb), kk=1,NZB)
+
+     ! Write mean velocities, and pressure:
+     write(1) (uavg(kk,lb), kk=1,NZB)
+     write(1) (vavg(kk,lb), kk=1,NZB)
+     write(1) (wavg(kk,lb), kk=1,NZB) 
+     write(1) (pavg(kk,lb), kk=1,NZB)
+ 
+     ! Write vorticities:    
+     write(1) (omgx2(kk,lb), kk=1,NZB)
+     write(1) (omgy2(kk,lb), kk=1,NZB)
+     write(1) (omgz2(kk,lb), kk=1,NZB)
+
+     ! Write q^2 and rms2 fluctuations:
+     write(1) (q2(kk,lb), kk=1,NZB)
+     write(1) (urms2(kk,lb), kk=1,NZB)
+     write(1) (vrms2(kk,lb), kk=1,NZB)
+     write(1) (wrms2(kk,lb), kk=1,NZB)
+     write(1) (prms2(kk,lb), kk=1,NZB)
+
+     ! Write dissipation and Taylor microscales:
+     write(1) (eps_nu(kk,lb), kk=1,NZB)
+     write(1) (lambdaf(kk,lb), kk=1,NZB)
+     write(1) (lambdag(kk,lb), kk=1,NZB)
+
+     ! Finally Reynolds stresses:
+     write(1) (uu(kk,lb), kk=1,NZB)
+     write(1) (vv(kk,lb), kk=1,NZB)
+     write(1) (ww(kk,lb), kk=1,NZB)
+     write(1) (uv(kk,lb), kk=1,NZB)
+     write(1) (uw(kk,lb), kk=1,NZB)
+     write(1) (vw(kk,lb), kk=1,NZB) 
+
+
+  enddo
+
+  close(1)
+
+  return
+  end subroutine
+
+
Index: ins_ab2rk3.F90
===================================================================
--- ins_ab2rk3.F90	(revision 0)
+++ ins_ab2rk3.F90	(revision 0)
@@ -0,0 +1,1024 @@
+!!****if* source/physics/IncompNS/IncompNSMain/constdens/ins_ab2rk3
+!!
+!!
+!! NAME
+!!
+!!  ins_ab2rk3
+!!
+!!
+!! SYNOPSIS
+!!
+!!  ins_ab2rk3(integer(IN) :: blockCount,
+!!             integer(IN) :: blockList(blockCount)
+!!             real(IN)    :: timeEndAdv
+!!             real(IN)    :: dt)
+!!
+!!
+!! DESCRIPTION
+!!
+!!  Performs a second order Adams Bashforth or third order Runge-
+!!  Kutta step on a fractional step time discretization of the 
+!!  Incompressible Navier Stokes flow problem.
+!!
+!!  The blockList and blockCount arguments tell this routine on
+!!  which blocks and on how many to operate.  blockList is an
+!!  integer array of size blockCount that contains the local
+!!  block numbers of blocks on which to advance.
+!!
+!!  dt gives the timestep through which this update should advance.
+!!
+!! ARGUMENTS
+!!
+!!  blockCount - the number of blocks in blockList
+!!  blockList  - array holding local IDs of blocks on which to advance
+!!  timeEndAdv - time level at the end of step
+!!  dt         - timestep
+!!
+!!***
+
+subroutine ins_ab2rk3( blockCount, blockList, timeEndAdv, dt)
+
+#include "Flash.h"
+#include "ImBound.h"
+#include "SolidMechanics.h"
+
+  ! Modules Use:
+#ifdef FLASH_GRID_PARAMESH
+  use physicaldata, ONLY : force_consistency,        &
+                           interp_mask_unk_res,      &
+                           interp_mask_facex_res,    &
+                           interp_mask_facey_res,    &
+                           interp_mask_facez_res,    &
+                           interp_mask_unk,      &
+                           interp_mask_facex,    &
+                           interp_mask_facey,    &
+                           interp_mask_facez
+  use workspace, ONLY :    interp_mask_work                           
+#endif    
+
+  use Grid_interface, ONLY : GRID_PDE_BND_PERIODIC, GRID_PDE_BND_NEUMANN, &
+                             Grid_getListOfBlocks, &
+                             Grid_getDeltas,         &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits, &
+                             Grid_fillGuardCells,    &
+                             Grid_putFluxData,       &
+                             Grid_getFluxData,       &
+                             Grid_conserveFluxes,    &
+                             Grid_conserveField,     &
+                             Grid_updateRefinement,  &
+                             Grid_solvePoisson, Grid_getBlkBoundBox, Grid_getBlkCenterCoords
+
+  use gr_interface, ONLY : gr_findMean
+
+  use ins_interface, only  :  ins_vt,&
+                           ins_rhs3d,&
+                           ins_rhs2d,&
+                       ins_predictor,&
+                      ins_divergence,&
+                       ins_corrector,&
+                         ins_fluxfix,&
+                       ins_fluxfix_p,&
+                   ins_computeQinout,&
+                   ins_rescaleVelout,&
+                   ins_convectVelout,&
+              ins_setInterpValsGcell,&
+                      ins_UstarStats,&
+                  ins_pressgradients
+
+  use IncompNS_data, ONLY : ins_isgs, ins_invRe, ins_intschm, ins_prescoeff, ins_meshMe,&
+                            ins_restart, ins_nstep, ins_Qin, ins_Qout, ins_predcorrflg, &
+                            ins_convvel, ins_alf, ins_gam, ins_rho, ins_gama, ins_alfa, &
+                            ins_rhoa, ins_outflowgridChanged, ins_tlevel, &
+                            ins_vardt, rkstep, ins_intschm_type
+
+  use Grid_Data, ONLY : gr_domainBC 
+    
+  use Timers_interface, ONLY : Timers_start, Timers_stop
+
+  use ImBound_interface, ONLY : ImBound
+ 
+  use SolidMechanics_interface, only : SolidMechanics
+
+  use Driver_data, ONLY : dr_globalMe, dr_nstep, dr_simTime
+
+  use Simulation_data, ONLY : sim_turbkin_expect, sim_scaleForce
+
+  implicit none
+
+#include "constants.h"
+#include "IncompNS.h"
+!#ifdef FLASH_GRID_PARAMESH
+!#include "Multigrid.h"
+!#endif
+  include "Flash_mpi.h"
+
+
+  !! ---- Argument List ----------------------------------
+  integer, INTENT(INOUT) :: blockCount
+  integer, INTENT(INOUT), dimension(MAXBLOCKS) :: blockList !blockCount
+  real,    INTENT(IN) :: timeEndAdv,dt
+  !! -----------------------------------------------------
+
+  integer, dimension(2,MDIM) :: blkLimits, blkLimitsGC
+
+  real, dimension(2,MDIM) :: boundBox
+
+
+  logical :: gcMask(NUNK_VARS+NDIM*NFACE_VARS)
+            
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+
+  integer :: lb,blockID,ii,jj,kk,ierr,i,j,k
+
+  real, dimension(GRID_IHI_GC+1,GRID_JHI_GC,GRID_KHI_GC) :: newu
+  real, dimension(GRID_IHI_GC,GRID_JHI_GC+1,GRID_KHI_GC) :: newv
+  real, dimension(GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC+1) :: neww
+
+  real, dimension(NFLUXES,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC) :: flxint_u
+  real, dimension(NFLUXES,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC) :: flxint_v
+  real, dimension(NFLUXES,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC) :: flxint_w
+
+  integer :: sx,sy,sz,ex,ey,ez
+
+  real dtdxdz,dtdydz,dtdxdy
+  
+  integer TA(2),count_rate
+  real*8  ET
+
+  integer TAIB(2),count_rateIB
+  real*8  ETIB
+
+  real maxfp,minfp,maxflb,minflb
+
+  real bsize(MDIM),coord(MDIM)
+  integer datasize(MDIM)
+
+  integer nxc, nyc, nzc
+  real del(MDIM)
+
+  integer, dimension(6) :: bc_types
+  integer :: idimn,ibound,eachBoundary
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+  real, dimension(2,6)  :: bc_values = 0.
+  real poisfact,alfadt
+
+  integer ist,itmx
+     
+  logical, save :: firstcall = .true.
+
+  integer :: sm_body_converge
+
+  ! debug VAR:
+  integer aa,bb,cc
+  real :: meanPres,meanVelx,meanVely,meanVelz
+  real :: minu,maxu,minv,maxv,minw,maxw,minp,maxp,mndivv,mxdivv
+  real :: vecminaux(5),vecmaxaux(5),vecmin(5),vecmax(5)
+
+  logical :: gridChanged 
+
+  real :: turbkin
+! --------------------------------------------------------------------------
+
+
+  CALL SYSTEM_CLOCK(TA(1),count_rate)  
+
+  newu = 0.
+  newv = 0.
+  neww = 0.
+  flxint_u = 0.
+  flxint_v = 0.
+  flxint_w = 0.
+
+
+  nxc = NXB + NGUARD + 1
+  nyc = NYB + NGUARD + 1
+  nzc = NZB + NGUARD + 1
+
+!!$  write(*,*) 'NXYZB=',NXB,NYB,NZB,NGUARD  
+!!$  write(*,*) 'interp_mask_unk=',interp_mask_unk
+!!$  write(*,*) 'interp_mask_facex=',interp_mask_facex
+!!$  write(*,*) 'interp_mask_facey=',interp_mask_facey
+!!$  write(*,*) 'interp_mask_facez=',interp_mask_facez
+!!$  write(*,*) 'interp_mask_unk_res=',interp_mask_unk_res
+!!$  write(*,*) 'interp_mask_facex_res=',interp_mask_facex_res
+!!$  write(*,*) 'interp_mask_facey_res=',interp_mask_facey_res
+!!$  write(*,*) 'interp_mask_facez_res=',interp_mask_facez_res
+
+
+  do idimn = 1,NDIM
+  do ibound = LOW, HIGH
+     eachBoundary = 2*(idimn-1)+ibound
+     select case (gr_domainBC(ibound,idimn))
+     case (PERIODIC)
+#ifdef FLASH_GRID_UG
+        bc_types(eachBoundary) = PERIODIC
+#else
+        bc_types(eachBoundary) = GRID_PDE_BND_PERIODIC !MG_BND_PERIODIC
+#endif
+     case (SLIP_INS,NOSLIP_INS,INFLOW_INS,NEUMANN_INS,MOVLID_INS,OUTFLOW_INS)
+#ifdef FLASH_GRID_UG
+        bc_types(eachBoundary) = OUTFLOW
+#else
+        bc_types(eachBoundary) = GRID_PDE_BND_NEUMANN !MG_BND_NEUMANN
+#endif
+     case default
+     if (ins_meshMe .eq. MASTER_PE) then
+        write(*,*) 'ins_ab2rk3 Error: Boundary Conditions match for Poisson Solver not defined.'
+        write(*,*) 'ins_ab2rk3 Error: LOW-HIGH,AXIS=',ibound,idimn
+        write(*,*) 'ins_ab2rk3 Error: gr_domainBC(ibound,idimn) =',gr_domainBC(ibound,idimn)
+     endif
+     call Driver_abortFlash('ins_ab2rk3 Error: BCs do not have matching Poisson solver BCs')
+     end select
+  enddo
+  enddo
+
+  ! shift timesteps
+  do i = -rkstep,-1
+     ins_vardt(i) = ins_vardt(i+1)
+  end do
+  ins_vardt(0) = dt
+ 
+
+  ! Select Euler step (for starting) of Adams-Bashforth coefficients
+  ! 2nd order Adams Bashforth coefficients (for constant timestep only):
+  if (ins_intschm .eq. AB2_SCHM) then
+     ins_gam(1) = 1.5
+     ins_gam(2) = 0.0
+     ins_gam(3) = 0.0
+     ins_rho(1) = -0.5
+     ins_rho(2) =  0.0
+     ins_rho(3) =  0.0
+
+     itmx = 1
+
+  ! 2nd Order Adams-Bashforth coefficents for variable timesteps
+  elseif (ins_intschm .eq. AB2_SCHM_V ) then
+     ins_gam(1) = 1+ins_vardt(0)/(2.*ins_vardt(-1))
+     ins_gam(2) = 0.0
+     ins_gam(3) = 0.0
+     ins_rho(1) = -ins_vardt(0)/(2.*ins_vardt(-1))
+     ins_rho(2) =  0.0
+     ins_rho(3) =  0.0
+
+     itmx = 1
+
+  ! 3rd order Runge Kutta coefficients
+  elseif (ins_intschm .eq. RK3_SCHM) then
+     ins_gam(1) = 8./15.
+     ins_gam(2) = 5./12.
+     ins_gam(3) = 3./4.
+     ins_rho(1) = 0.0
+     ins_rho(2) = -17./60.
+     ins_rho(3) = -5./12.
+
+     itmx = 3 
+  else
+     if (ins_meshMe .eq. MASTER_PE) then
+        write(*,*) 'Unknown Incompressible Flow integrator scheme:'
+        write(*,*) 'ins_schm=',ins_intschm
+        write(*,*) 'where ins_schm=2 Adams-Bashforth, ins_schm=3 Runge-Kutta'
+     endif
+  endif
+
+  ! Euler coefficients (starting from scratch for Adams-Bashforth):
+  if ((ins_nstep .eq. 1) .and. (ins_restart .eqv. .false.) .and. &
+      (ins_intschm_type .eq. INS_INTSCHM_MULTISTEP)) then
+     ins_gam(1) = 1.0; ins_gam(2) = 0.0; ins_gam(3) = 0.0
+     ins_rho(1) = 0.0; ins_rho(2) = 0.0; ins_rho(3) = 0.0
+     itmx = 1
+  endif
+
+  ins_alf = ins_gam + ins_rho
+ 
+  ! Set Interpolation values for guardcell-filling:
+  call ins_setInterpValsGcell(.true.)
+
+!!$  ! Fill Guardcells for all variables if grid has changed:
+!!$  if (ins_outflowgridChanged) then
+!!$     gcMask = .TRUE.
+!!$     call Grid_fillGuardCells(CENTER_FACES,ALLDIR,&
+!!$       maskSize=NUNK_VARS+NDIM*NFACE_VARS,mask=gcMask)
+!!$     ins_outflowgridChanged = .false.
+!!$  endif
+
+
+  ins_tlevel = timeEndAdv - dt
+
+  ! Timestep Loop:
+  do ist = 1,itmx
+
+  ins_gama = ins_gam(ist)
+  ins_rhoa = ins_rho(ist)
+  ins_alfa = ins_alf(ist)
+
+  ins_tlevel = ins_tlevel + ins_alfa*dt
+
+  ! These two subroutine calls ar used in case of outflow BCs, only when NEUMANN_INS and
+  ! OUTFLOW_INS are present.
+  ! Compute inflow volume ratio: (Not computed on NOT_BOUNDARY, NEUMANN_INS, OUTFLOW_INS)
+  call ins_computeQinout( blockCount, blockList, .true., ins_Qin)
+  
+  ! For OUTFLOW_INS condition compute convective velocity
+  call ins_convectVelout( blockCount, blockList, ins_convvel)
+  !if(ins_meshMe .eq. MASTER_PE) write(*,*) 'After convect',ins_convvel(HIGH,:)  
+
+  ! TURBULENT VISCOSITY COMPUTATION:
+  ! --------- --------- -----------
+#if NDIM == 3
+  if (ins_isgs .NE. 0) then
+     do lb = 1,blockCount
+        blockID = blockList(lb)
+
+        ! Get blocks dx, dy ,dz:
+        call Grid_getDeltas(blockID,del)
+
+        ! Get blocks coord and bsize
+        ! Bounding box:
+        call Grid_getBlkBoundBox(blockId,boundBox)
+        bsize(1:NDIM) = boundBox(2,1:NDIM) - boundBox(1,1:NDIM)
+
+        call Grid_getBlkCenterCoords(blockId,coord)
+
+        ! Point to blocks center and face vars:
+        call Grid_getBlkPtr(blockID,solnData,CENTER)
+        call Grid_getBlkPtr(blockID,facexData,FACEX)
+        call Grid_getBlkPtr(blockID,faceyData,FACEY)
+        call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+        ! calculate turbulent viscosity
+        call ins_vt(ins_isgs,NGUARD,nxc,nyc,nzc,                   &
+                    ins_invRe,del(DIR_X),del(DIR_Y),del(DIR_Z),    &
+                    coord,bsize,                                   &
+                    facexData,&
+                    faceyData,&
+                    facezData,&
+                    solnData)            
+
+        ! Release pointers:
+        call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+        call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+        call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+        call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+
+     enddo
+     ! apply BC and fill guardcells for turbulent viscosity
+     gcMask = .FALSE.
+     gcMask(TVIS_VAR) = .TRUE.                            ! only turbulent viscosity
+     call Grid_fillGuardCells(CENTER_FACES,ALLDIR,&
+       maskSize=NUNK_VARS+NDIM*NFACE_VARS,mask=gcMask)             
+
+  else
+    do lb = 1,blockCount
+        blockID = blockList(lb)
+
+        ! Point to blocks center and face vars:
+        call Grid_getBlkPtr(blockID,solnData,CENTER)
+
+        solnData(TVIS_VAR,:,:,:) = 0.
+
+        ! Release pointers:
+        call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+
+    enddo
+  endif
+#endif
+
+!!$  CALL SYSTEM_CLOCK(TA(1),count_rate)  
+
+
+  ! Compute forcing pressure gradients if required:
+  call ins_pressgradients(ins_tlevel,ins_alfa*dt)
+
+
+!  call Timers_start("TurbstatsForForcing") ! Shizhao Wang
+      ! Compute Time averaged Statistics
+!      call ins_turbstats(dr_globalMe,dr_nstep,dr_simTime,&
+!                         ins_invRe,blockCount,blockList,turbkin)
+!      scaleForce = sim_turbkin_expect/turbkin
+      if(ins_meshMe == MASTER_PE) write(*,*) 'tke0, tke0/tke:', sim_turbkin_expect, sim_scaleForce
+!  call Timers_stop("TurbstatsForForcing")
+
+
+  call Timers_start("RightHandSide_Predictor")
+  ! COMPUTE RIGHT HAND SIDE AND PREDICTOR STEP:
+  ! ------- ----- ---- ---- --- --------- ----
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     ! Get Blocks internal limits indexes:
+     call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC) 
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+
+#if NDIM == 3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+     ! compute RHS of momentum equation
+     call ins_rhs3d (  facexData(VELC_FACE_VAR,:,:,:),            &
+                       faceyData(VELC_FACE_VAR,:,:,:),            & 
+                       facezData(VELC_FACE_VAR,:,:,:),            &
+                       solnData(TVIS_VAR,:,:,:),                  &
+                       facexData(FBAO_FACE_VAR,:,:,:)*sim_scaleForce,            & ! Force distribution for
+                       faceyData(FBAO_FACE_VAR,:,:,:)*sim_scaleForce,            & ! Linear forcing.
+                       facezData(FBAO_FACE_VAR,:,:,:)*sim_scaleForce,            &
+                       ins_invRe,                                 &
+                       blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS),&
+                       blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS),&
+                       blkLimits(LOW,KAXIS),blkLimits(HIGH,KAXIS),&
+                       del(DIR_X),del(DIR_Y),del(DIR_Z),newu,newv,neww )
+
+#elif NDIM ==2
+     ! compute RHS of momentum equation
+     call ins_rhs2d(  facexData(VELC_FACE_VAR,:,:,:),            &
+                      faceyData(VELC_FACE_VAR,:,:,:),            &
+                      ins_invRe,                                 &
+                      blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS),&
+                      blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS),&
+                      del(DIR_X),del(DIR_Y),newu,newv)
+     
+#endif
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     ! compute intermediate velocities
+     call ins_predictor(facexData(VELC_FACE_VAR,:,:,:),&
+                        faceyData(VELC_FACE_VAR,:,:,:),&
+                        facezData(VELC_FACE_VAR,:,:,:),&
+                        newu,newv,neww,                &
+                        facexData(RHDS_FACE_VAR,:,:,:),&
+                        faceyData(RHDS_FACE_VAR,:,:,:),&
+                        facezData(RHDS_FACE_VAR,:,:,:),&
+                        solnData(PRES_VAR,:,:,:),      &
+                        dt,del(DIR_X),del(DIR_Y),del(DIR_Z),      & 
+            blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS),&
+            blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS),&
+            blkLimits(LOW,KAXIS),blkLimits(HIGH,KAXIS),&
+            ins_gama,ins_rhoa,ins_alfa )
+
+     ! save RHS for next step
+     facexData(RHDS_FACE_VAR,:,:,:) = newu(:,:,:)
+     faceyData(RHDS_FACE_VAR,:,:,:) = newv(:,:,:)
+
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+
+
+#if NDIM ==3
+     facezData(RHDS_FACE_VAR,:,:,:) = neww(:,:,:)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif
+
+
+  enddo
+  call Timers_stop("RightHandSide_Predictor")
+
+!!$   !CALL SYSTEM_CLOCK(TA(2),count_rate)
+!!$   !ET=REAL(TA(2)-TA(1),8)/count_rate
+!!$   !write(*,*) 'Predictor time =',ET
+
+  ! Substract mean velocities:
+!  call ins_substractmeanvel_z(VELC_FACE_VAR,blockCount,blockList)
+   call ins_substractmeanvel(dr_globalMe,dr_nstep,dr_simTime,& 
+                              ins_invRe,blockCount,blockList) 
+
+  call Timers_start("Gcell_IntermVelocs")
+  ! APPLY BC AND FILL GUARDCELLS FOR INTERMEDIATE VELOCITIES:
+  ! ----- -- --- ---- ---------- --- ------------ ----------
+  gcMask = .FALSE.
+  gcMask(NUNK_VARS+VELC_FACE_VAR) = .TRUE.                 ! ustar
+  gcMask(NUNK_VARS+1*NFACE_VARS+VELC_FACE_VAR) = .TRUE.    ! vstar
+#if NDIM == 3
+  gcMask(NUNK_VARS+2*NFACE_VARS+VELC_FACE_VAR) = .TRUE.    ! wstar
+#endif
+  ins_predcorrflg = .true.
+  call Grid_fillGuardCells(CENTER_FACES,ALLDIR,&
+       maskSize=NUNK_VARS+NDIM*NFACE_VARS,mask=gcMask)           
+
+  ! FIX FLUXES FOR USTAR: (Only for AMR grids)
+  ! --- ------ --- -----
+#ifdef FLASH_GRID_PARAMESH
+  ! Fix fluxes at block boundaries
+  call ins_fluxfix(NGUARD,nxc,nyc,nzc,nxc-1,nyc-1,nzc-1,&
+                   blockCount,blockList)
+#endif
+  call Timers_stop("Gcell_IntermVelocs")
+
+!!$  ! Compute outflow mass volume ratio: (computed on NEUMANN_INS, OUTFLOW_INS)
+!!$  call ins_computeQinout( blockCount, blockList, .false., ins_Qout)
+!!$  !write(*,*) 'Qout before ref=',ins_Qout
+!!$
+!!$  ! Rescale Velocities at outflows for overall conservation: 
+!!$  call ins_rescaleVelout(  blockCount, blockList, ins_Qin, ins_Qout)
+
+  if (ist .eq. 1) then
+  call Timers_start("Grid_updateRefinement")
+  call Grid_updateRefinement( ins_nstep, timeEndAdv ,gridChanged)
+  call Grid_getListOfBlocks(LEAF,blockList,blockCount)
+  call Timers_stop("Grid_updateRefinement")
+  !  ! Write Ustar:
+  ! call outtotecplot_uv(ins_meshMe,ins_tlevel,dt,ins_nstep,100, &
+  !                      0.0,blockList,blockCount,1,1.)
+  endif
+
+
+  ! Copy the original ustar and pressure to velo, preo
+  do lb=1,blockCount
+     blockID = blockList(lb)
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+#if NDIM ==3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     facezData(VELO_FACE_VAR,:,:,:) = facezData(VELC_FACE_VAR,:,:,:)
+#endif
+     ! Velocities
+     facexData(VELO_FACE_VAR,:,:,:) = facexData(VELC_FACE_VAR,:,:,:)
+     faceyData(VELO_FACE_VAR,:,:,:) = faceyData(VELC_FACE_VAR,:,:,:)
+     ! Pressure
+     solnData(PREO_VAR,:,:,:)  = solnData(PRES_VAR,:,:,:)
+
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+#if NDIM ==3
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif 
+  enddo
+  
+  ! Begin FSI subiterations:
+  sm_body_converge=SM_NOTCONVERGED
+  do while(sm_body_converge .eq. SM_NOTCONVERGED)
+
+
+  ! Copy the original ustar and pressure from velo, preo
+  do lb=1,blockCount
+     blockID = blockList(lb)
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+#if NDIM ==3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     facezData(VELC_FACE_VAR,:,:,:) = facezData(VELO_FACE_VAR,:,:,:)
+#endif
+     ! Velocities
+     facexData(VELC_FACE_VAR,:,:,:) = facexData(VELO_FACE_VAR,:,:,:)
+     faceyData(VELC_FACE_VAR,:,:,:) = faceyData(VELO_FACE_VAR,:,:,:)
+     ! Pressure
+     solnData(PRES_VAR,:,:,:)  = solnData(PREO_VAR,:,:,:) 
+
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER) 
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+#if NDIM ==3
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif 
+  enddo
+
+ 
+  ! Call Solid Mechanics:
+  call Timers_start("SolidMechanics.")
+  call SolidMechanics(SM_ADVANCE)  
+  call Timers_stop("SolidMechanics.")
+
+!  CALL SYSTEM_CLOCK(TAIB(1),count_rateIB)
+
+  ! Force Immersed Boundaries:
+  call Timers_start("Immersed Boundaries.")
+  call ImBound( blockCount, blockList, ins_alfa*dt,FORCE_FLOW)
+  call Timers_stop("Immersed Boundaries.")
+
+!  CALL SYSTEM_CLOCK(TAIB(2),count_rateIB)
+!  ETIB=REAL(TAIB(2)-TAIB(1),8)/count_rateIB
+!  if (ins_meshMe .eq. MASTER_PE)  write(*,*) 'Total IB Time =',ETIB
+ 
+  ! Compute DivUstar - delta_mass and print to screen, add to ins_Qin:
+  call ins_UstarStats( blockCount, blockList, .true., .true.)
+
+
+  ! Compute outflow mass volume ratio: (computed on NEUMANN_INS, OUTFLOW_INS)
+  call ins_computeQinout( blockCount, blockList, .false., ins_Qout)
+  !write(*,*) 'Qout after ref=',ins_Qout
+
+  ! Rescale Velocities at outflows for overall conservation: 
+  call ins_rescaleVelout(  blockCount, blockList, ins_Qin, ins_Qout)
+
+  ! DIVERGENCE OF USTAR:
+  ! ---------- -- -----
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     ! Get Blocks internal limits indexes:
+     call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC) 
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+
+#if NDIM ==3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+#endif
+
+
+     ! compute divergence of intermediate velocities
+     call ins_divergence(facexData(VELC_FACE_VAR,:,:,:),&
+                         faceyData(VELC_FACE_VAR,:,:,:),&
+                         facezData(VELC_FACE_VAR,:,:,:),&
+             blkLimits(LOW,IAXIS),blkLimits(HIGH,IAXIS),&
+             blkLimits(LOW,JAXIS),blkLimits(HIGH,JAXIS),&
+             blkLimits(LOW,KAXIS),blkLimits(HIGH,KAXIS),&
+                       del(DIR_X),del(DIR_Y),del(DIR_Z),&
+                       solnData(DUST_VAR,:,:,:) )
+
+
+     ! Poisson RHS source vector
+     solnData(DUST_VAR,                                   &
+          blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS),     &
+          blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS),     &
+          blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)) =   &
+     solnData(DUST_VAR,                                   &
+          blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS),     &
+          blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS),     &
+          blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS))/(dt*ins_alfa)              
+
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+#if NDIM ==3
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif            
+  enddo
+
+!  call gr_findMean(DUST_VAR,2,.false.,meanPres)
+!  if (ins_meshMe .eq. MASTER_PE) write(*,*) 'Mean Div Ustar A=',meanPres*(dt*ins_alfa)
+
+  call Timers_start("Grid_solvePoisson")
+  ! SOLUTION OF POISSON EQUATION FOR PRESSURE:
+  ! -------- -- ------- -------- --- --------
+  poisfact = 1.0 
+  call Grid_solvePoisson (DELP_VAR, DUST_VAR, bc_types, bc_values, poisfact) 
+  call Timers_stop("Grid_solvePoisson")
+
+!  call gr_findMean(PRES_VAR,2,.false.,meanPres)
+!  if (ins_meshMe .eq. MASTER_PE) write(*,*) 'Mean Pressure=',meanPres
+!  call gr_findMean(DELP_VAR,2,.false.,meanPres)
+!  if (ins_meshMe .eq. MASTER_PE) write(*,*) 'Mean DeltaP=',meanPres
+
+  call Timers_start("Gcells_DelP")  
+   ! FIX FLUXES FOR dDELP/dxi :
+#ifdef FLASH_GRID_UG
+  ! Don't Fix Fluxes in block Boundaries
+  ! Fill Guardcells for DelP: Used in boundary dDelp/dx fluxes:
+  gcMask = .FALSE.
+  gcMask(DELP_VAR) = .TRUE.
+  call Grid_fillGuardCells(CENTER_FACES,ALLDIR,  &
+      maskSize=NUNK_VARS+NDIM*NFACE_VARS,mask=gcMask, &
+      selectBlockType=ACTIVE_BLKS)
+ ! ---------------------------------------------------------------------
+#else
+  ! fix fluxes at block boundaries
+  ! fix dp gradient fluxes at block boundaries
+  call ins_fluxfix_p(NGUARD,nxc,nyc,nzc,nxc-1,nyc-1,nzc-1,&
+                     DELP_VAR,blockCount,blockList)
+#endif
+  call Timers_stop("Gcells_DelP")
+ 
+
+  call Timers_start("Corrector")
+  ! CORRECTOR STEP:
+  ! --------- ---
+  alfadt = ins_alfa*dt
+  do lb = 1,blockCount
+
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+#if NDIM == 2
+     ! Case 2D take depth to be 1:
+     del(DIR_Z) = 1. 
+#endif
+
+     dtdydz = alfadt*(del(DIR_Y)*del(DIR_Z))**(-1.)   !(dy*dz)**-1.
+     dtdxdz = alfadt*(del(DIR_X)*del(DIR_Z))**(-1.)   !(dx*dz)**-1.
+     dtdxdy = alfadt*(del(DIR_X)*del(DIR_Y))**(-1.)   !(dx*dy)**-1.
+
+     ! Get Index Limits:
+     call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC)
+
+     datasize(1:MDIM)=blkLimitsGC(HIGH,1:MDIM)-blkLimitsGC(LOW,1:MDIM)+1   
+
+     ! Positions in face arrays where flux vars have been stored
+     sx = NGUARD+1
+     sy = NGUARD*K2D+1
+     sz = NGUARD*K3D+1
+     ex = dataSize(DIR_X)-NGUARD
+     ey = dataSize(DIR_Y)-NGUARD*K2D
+     ez = dataSize(DIR_Z)-NGUARD*K3D
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+
+#if NDIM ==3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+#endif
+
+#ifdef FLASH_GRID_UG
+     ! UNIFORM Grid:
+     ! west face
+     facexData(VELC_FACE_VAR,sx,sy:ey,sz:ez) =                  &
+          facexData(VELC_FACE_VAR,sx,sy:ey,sz:ez) -             &
+          alfadt/del(DIR_X)*(solnData(DELP_VAR,sx,sy:ey,sz:ez)- &
+                             solnData(DELP_VAR,sx-1,sy:ey,sz:ez))
+
+     ! east face
+     facexData(VELC_FACE_VAR,ex+1,sy:ey,sz:ez) =                  &
+          facexData(VELC_FACE_VAR,ex+1,sy:ey,sz:ez) -             &
+          alfadt/del(DIR_X)*(solnData(DELP_VAR,ex+1,sy:ey,sz:ez)- &
+                             solnData(DELP_VAR,ex,sy:ey,sz:ez))
+
+     ! south face
+     faceyData(VELC_FACE_VAR,sx:ex,sy,sz:ez) =                  &
+          faceyData(VELC_FACE_VAR,sx:ex,sy,sz:ez) -             &
+          alfadt/del(DIR_Y)*(solnData(DELP_VAR,sx:ex,sy,sz:ez)- &
+                             solnData(DELP_VAR,sx:ex,sy-1,sz:ez))
+
+     ! north face
+     faceyData(VELC_FACE_VAR,sx:ex,ey+1,sz:ez) =                  &
+          faceyData(VELC_FACE_VAR,sx:ex,ey+1,sz:ez) -             &
+          alfadt/del(DIR_Y)*(solnData(DELP_VAR,sx:ex,ey+1,sz:ez)- &
+                             solnData(DELP_VAR,sx:ex,ey,sz:ez))
+
+
+#if NDIM == 3
+     ! front face
+     facezData(VELC_FACE_VAR,sx:ex,sy:ey,sz) =                  &
+          facezData(VELC_FACE_VAR,sx:ex,sy:ey,sz) -             &
+          alfadt/del(DIR_Z)*(solnData(DELP_VAR,sx:ex,sy:ey,sz)- &
+                             solnData(DELP_VAR,sx:ex,sy:ey,sz-1))
+
+     ! back face
+     facezData(VELC_FACE_VAR,sx:ex,sy:ey,ez+1) =                  &
+          facezData(VELC_FACE_VAR,sx:ex,sy:ey,ez+1) -             &
+          alfadt/del(DIR_Z)*(solnData(DELP_VAR,sx:ex,sy:ey,ez+1)- &
+                             solnData(DELP_VAR,sx:ex,sy:ey,ez))
+#endif
+
+#else
+
+     ! AMR GRID:
+     ! update block boundary velocities using corrected fluxes
+     ! X direction:
+     call Grid_getFluxData(blockID, IAXIS, &
+                           flxint_u, dataSize)      
+
+
+     ! west face
+     facexData(VELC_FACE_VAR,sx,sy:ey,sz:ez) =       &
+          facexData(VELC_FACE_VAR,sx,sy:ey,sz:ez) -  &
+          dtdydz*flxint_u(VELC_FLUX,sx,sy:ey,sz:ez)
+
+     ! east face
+     facexData(VELC_FACE_VAR,ex+1,sy:ey,sz:ez) =       &
+          facexData(VELC_FACE_VAR,ex+1,sy:ey,sz:ez) -  &
+          dtdydz*flxint_u(VELC_FLUX,ex+1,sy:ey,sz:ez)                
+
+
+     ! Y direction:
+     call Grid_getFluxData(blockID, JAXIS, &
+                           flxint_v, dataSize)       
+
+     ! south face
+     faceyData(VELC_FACE_VAR,sx:ex,sy,sz:ez) =       &
+          faceyData(VELC_FACE_VAR,sx:ex,sy,sz:ez) -  &
+          dtdxdz*flxint_v(VELC_FLUX,sx:ex,sy,sz:ez)
+
+     ! north face
+     faceyData(VELC_FACE_VAR,sx:ex,ey+1,sz:ez) =       &
+          faceyData(VELC_FACE_VAR,sx:ex,ey+1,sz:ez) -  &
+          dtdxdz*flxint_v(VELC_FLUX,sx:ex,ey+1,sz:ez)
+
+#if NDIM == 3
+
+     ! Z direction:
+     call Grid_getFluxData(blockID, KAXIS, &
+                           flxint_w, dataSize)     
+
+     ! front face
+     facezData(VELC_FACE_VAR,sx:ex,sy:ey,sz) =       &
+          facezData(VELC_FACE_VAR,sx:ex,sy:ey,sz) -  &
+          dtdxdy*flxint_w(VELC_FLUX,sx:ex,sy:ey,sz)
+
+     ! back face
+     facezData(VELC_FACE_VAR,sx:ex,sy:ey,ez+1) =       &
+          facezData(VELC_FACE_VAR,sx:ex,sy:ey,ez+1) -  &
+          dtdxdy*flxint_w(VELC_FLUX,sx:ex,sy:ey,ez+1)
+
+#endif
+
+#endif
+
+
+     ! update divergence-free velocities (not on block boundary)
+     call ins_corrector( facexData(VELC_FACE_VAR,:,:,:),&
+                         faceyData(VELC_FACE_VAR,:,:,:),&
+                         facezData(VELC_FACE_VAR,:,:,:),&
+                         solnData(DELP_VAR,:,:,:),& 
+                         sx,ex,sy,ey,sz,ez,&
+                         dt,del(DIR_X),del(DIR_Y),del(DIR_Z),ins_alfa)
+
+     ! update pressure
+     solnData(PRES_VAR,:,:,:) = ins_prescoeff*solnData(PRES_VAR,:,:,:) + &
+                                solnData(DELP_VAR,:,:,:) 
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+#if NDIM == 3
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif
+  enddo ! End of corrector loop
+  call Timers_stop("Corrector")
+
+  call Timers_start("Gcell_FinalVelocsP")
+  ! FILL GUARDCELLS FOR FINAL VELOCITIES AND PRESSURE:
+  ! ---- ---------- --- ----- ---------- --- --------
+  ! The pressure fill is used to compute distributed forces on
+  ! immersed bodies.
+  gcMask = .FALSE.
+  gcMask(PRES_VAR) = .TRUE.                                ! pressure
+  gcMask(NUNK_VARS+VELC_FACE_VAR) = .TRUE.                 ! u
+  gcMask(NUNK_VARS+1*NFACE_VARS+VELC_FACE_VAR) = .TRUE.    ! v
+#if NDIM == 3
+  gcMask(NUNK_VARS+2*NFACE_VARS+VELC_FACE_VAR) = .TRUE.    ! w
+#endif
+  ins_predcorrflg = .false.
+  call Grid_fillGuardCells(CENTER_FACES,ALLDIR,&
+       maskSize=NUNK_VARS+NDIM*NFACE_VARS,mask=gcMask)         
+  call Timers_stop("Gcell_FinalVelocsP")
+
+!!$  ! FIX FLUXES FOR UFINAL: (Only for AMR grids, needed when using 
+!!$  ! boundary restriction of order > 1, and force_consistency_at_srl_interfaces=True)
+!!$  ! --- ------ --- -----
+!!$#ifdef FLASH_GRID_PARAMESH
+!!$  if (force_consistency) then
+!!$  ! Fix fluxes at block boundaries
+!!$  call ins_fluxfix(NGUARD,nxc,nyc,nzc,nxc-1,nyc-1,nzc-1,&
+!!$                   blockCount,blockList)
+!!$  endif
+!!$#endif
+
+  call Timers_start("ImmBoundaries_Forces")
+  ! Compute forces on immersed bodies:
+  call ImBound( blockCount, blockList, ins_alfa*dt,COMPUTE_FORCES)
+  call Timers_stop("ImmBoundaries_Forces")
+
+
+  
+
+  ! Call Solid Mechanics:
+  call Timers_start("SolidMechanics.")
+  call SolidMechanics(SM_CHECKCONVERG,convflag_all=sm_body_converge)  
+  call Timers_stop("SolidMechanics.")
+
+  enddo ! End of fsi subiterations
+
+
+  enddo ! End  of time substeps loop
+
+
+  ! Restore Interpolation values for guardcell-filling:
+  call ins_setInterpValsGcell(.false.)
+
+  ! ------------------------------------------------------------------------------------------
+  ! Check min max divergence:
+  ! ----- --- --- ----------
+  mxdivv = -10.**(10.)
+  mndivv =  10.**(10.)  
+  maxu   = mxdivv; maxv = maxu; maxw = maxu; maxp = maxu;
+  minu   = mndivv; minv = minu; minw = minu; minp = minu;
+  do lb = 1,blockCount
+
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+
+#if NDIM == 3
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+ 
+  mxdivv = max( mxdivv,maxval( (facexData(VELC_FACE_VAR,NGUARD+2:nxc,NGUARD+1:nyc-1,NGUARD+1:nzc-1) - &
+                    facexData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_X) + &
+                   (faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+2:nyc,NGUARD+1:nzc-1) - &
+                    faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_Y) + &
+                   (facezData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+2:nzc) - &
+                    facezData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_Z) ))
+
+  mndivv = min( mndivv,minval( (facexData(VELC_FACE_VAR,NGUARD+2:nxc,NGUARD+1:nyc-1,NGUARD+1:nzc-1) - &
+                    facexData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_X) + &
+                   (faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+2:nyc,NGUARD+1:nzc-1) - &
+                    faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_Y) + &
+                   (facezData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+2:nzc) - &
+                    facezData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,NGUARD+1:nzc-1))/del(DIR_Z) ))
+
+
+  maxu = max(maxu,maxval(facexData(VELC_FACE_VAR,GRID_ILO:GRID_IHI+1,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI)))
+  minu = min(minu,minval(facexData(VELC_FACE_VAR,GRID_ILO:GRID_IHI+1,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI)))
+
+  maxv = max(maxv,maxval(faceyData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI+1,GRID_KLO:GRID_KHI)))
+  minv = min(minv,minval(faceyData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI+1,GRID_KLO:GRID_KHI)))
+
+  maxw = max(maxw,maxval(facezData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI+1)))
+  minw = min(minw,minval(facezData(VELC_FACE_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI+1)))
+
+  maxp = max(maxp,maxval(solnData(PRES_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI)))
+  minp = min(minp,minval(solnData(PRES_VAR,GRID_ILO:GRID_IHI,GRID_JLO:GRID_JHI,GRID_KLO:GRID_KHI)))
+
+
+#elif NDIM == 2
+
+  mxdivv = max( mxdivv,maxval( (facexData(VELC_FACE_VAR,NGUARD+2:nxc,NGUARD+1:nyc-1,1) - &
+                    facexData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,1))/del(DIR_X) + &
+                   (faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+2:nyc,1) - &
+                    faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,1))/del(DIR_Y) ))
+
+  mndivv = min( mndivv,minval( (facexData(VELC_FACE_VAR,NGUARD+2:nxc,NGUARD+1:nyc-1,1) - &
+                    facexData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,1))/del(DIR_X) + &
+                   (faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+2:nyc,1) - &
+                    faceyData(VELC_FACE_VAR,NGUARD+1:nxc-1,NGUARD+1:nyc-1,1))/del(DIR_Y) ))
+
+
+#endif
+
+     call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+#if NDIM == 3
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+#endif
+  enddo
+
+  vecmaxaux(1) = mxdivv
+  vecminaux(1) = mndivv
+  vecmaxaux(2) = maxu
+  vecminaux(2) = minu
+  vecmaxaux(3) = maxv
+  vecminaux(3) = minv
+  vecmaxaux(4) = maxw
+  vecminaux(4) = minw
+  vecmaxaux(5) = maxp
+  vecminaux(5) = minp
+  
+  call MPI_Allreduce(vecmaxaux, vecmax, 5, FLASH_REAL,&
+                     MPI_MAX, MPI_COMM_WORLD, ierr)
+
+  call MPI_Allreduce(vecminaux, vecmin, 5, FLASH_REAL,&
+                     MPI_MIN, MPI_COMM_WORLD, ierr)
+  
+
+  if (ins_meshMe .eq. MASTER_PE) then
+     write(*,*) ' '
+     write(*,'(A24,2g14.6)') ' Min , Max  U =',vecmin(2),vecmax(2) !minu,maxu
+     write(*,'(A24,2g14.6)') ' Min , Max  V =',vecmin(3),vecmax(3) !minv,maxv
+     write(*,'(A24,2g14.6)') ' Min , Max  W =',vecmin(4),vecmax(4) !minw,maxw
+     write(*,'(A24,2g14.6)') ' Min , Max  P =',vecmin(5),vecmax(5) !minp,maxp
+     write(*,'(A24,2g14.6)') ' Min , Max  Divergence =',vecmin(1),vecmax(1) !mndivv,mxdivv
+  endif
+
+  !----------------------------------------------------------------------------------------------------
+  
+
+
+  CALL SYSTEM_CLOCK(TA(2),count_rate)
+  ET=REAL(TA(2)-TA(1),8)/count_rate
+  if (ins_meshMe .eq. MASTER_PE)  write(*,*) 'Total AB Step Time =',ET
+  
+
+END SUBROUTINE ins_ab2rk3
+
+
Index: ins_turbstats.F90
===================================================================
--- ins_turbstats.F90	(revision 0)
+++ ins_turbstats.F90	(revision 0)
@@ -0,0 +1,362 @@
+! subroutine ins_turbstats
+! Computes turbulent statistics for isotropic turbulence simulations
+!
+! Marcos Vanella, July 2007
+! --------------------------------------------------------------------------
+
+!#define CONST_INPUT_ENG
+
+  subroutine ins_turbstats(mype,istep,time,mvisc, &
+                           blockCount,blockList,turbkin)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits
+
+  use Simulation_data, ONLY : sim_turbkin_expect, sim_scaleForce, sim_fbao
+      
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "IncompNS.h"
+  include 'mpif.h'
+
+  integer :: mype, istep
+  real :: time, mvisc, turbkin
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+  integer, parameter ::  ng = NGUARD
+  integer, parameter ::  nxi= NGUARD + NXB
+  integer, parameter ::  nyj= NGUARD + NYB
+  integer, parameter ::  nzk= NGUARD + NZB
+  integer, parameter ::  nxc= NGUARD + NXB + 1
+  integer, parameter ::  nyc= NGUARD + NYB + 1
+  integer, parameter ::  nzc= NGUARD + NZB + 1
+
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+  
+  real del(3),dx,dy,dz
+  real turbkinaux,volcell,tvol,tvolaux
+  real varl,varlaux,vart,vartaux,dudx_v,dudy_v
+  real lambdaf,lambdag
+  real uavg,vavg,wavg,uavgaux,vavgaux,wavgaux,fconstn
+  real dissavg,dissavgaux
+
+  integer lb,blockID,ierr
+
+  real, parameter :: diss = 0.4
+
+  logical, save :: initfile = .TRUE.
+
+  ! -------------------------------------------------------------------
+  ! Average velocities, Check there is no drift:
+  uavg = 0.
+  vavg = 0.
+  wavg = 0.
+  tvol = 0.
+
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     ! Cell volume:
+     volcell = del(DIR_X)*del(DIR_Y)*del(DIR_Z) ! dx*dy*dz
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+     ! U average:
+     uavg = uavg + &
+      sum(facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk))*volcell
+
+     ! V average:
+     vavg = vavg + &
+      sum(faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk))*volcell
+
+     ! W average:
+     wavg = wavg + &
+      sum(facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc))*volcell
+
+     ! Sum to processors total volume:
+     tvol = tvol + real(NXB*NYB*NZB)*volcell
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+  
+
+  ! Sum processors average velocities:
+  uavgaux = uavg
+  call MPI_Allreduce(uavgaux, uavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+  vavgaux = vavg
+  call MPI_Allreduce(vavgaux, vavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+  wavgaux = wavg
+  call MPI_Allreduce(wavgaux, wavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr) 
+
+
+  ! Sum processors volumes
+  tvolaux = tvol  
+  call MPI_Allreduce(tvolaux, tvol, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr)
+
+
+  ! Average velocities:
+  uavg = uavg/tvol
+  vavg = vavg/tvol
+  wavg = wavg/tvol
+
+
+  if (mype .eq. 0) then
+
+      if (initfile) then
+         OPEN(UNIT=240,FILE='./IOData/AVGVELS.res',STATUS='REPLACE', &
+              FORM='formatted')
+         write(240,'(I16,4g20.12)')istep,time,uavg,vavg,wavg
+         close(240)
+      
+      else
+         OPEN(UNIT=240,FILE='./IOData/AVGVELS.res',STATUS='OLD',     &
+              FORM='formatted',POSITION='APPEND')
+         write(240,'(I16,4g20.12)')istep,time,uavg,vavg,wavg
+         close(240)
+      endif
+
+   endif
+
+  ! Substract Mean Velocities: 
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     
+     facexData(VELC_FACE_VAR,:,:,:) = facexData(VELC_FACE_VAR,:,:,:) - uavg
+     faceyData(VELC_FACE_VAR,:,:,:) = faceyData(VELC_FACE_VAR,:,:,:) - vavg
+     facezData(VELC_FACE_VAR,:,:,:) = facezData(VELC_FACE_VAR,:,:,:) - wavg
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+
+
+  ! -------------------------------------------------------------------
+
+
+  ! -------------------------------------------------------------------
+  ! Compute Turbulent Kinetic Energy and Taylor Microscales:
+  turbkin = 0.
+  tvol    = 0.
+  varl    = 0.
+  vart    = 0.
+
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Get blocks dx, dy ,dz:
+     call Grid_getDeltas(blockID,del)
+
+     dx = del(DIR_X)
+     dy = del(DIR_Y)
+     dz = del(DIR_Z)
+
+     ! Cell volume:
+     volcell = dx*dy*dz
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,solnData,CENTER)
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+
+     ! Turbulent kinnetic energy in cell centers of block,
+     ! zero mean velocities:
+!!$     unk(3,ng+1:nxi,ng+1:nyj,ng+1:nzk,lb) = .5/4.*(         &
+!!$          (facevarx(1,ng+1:nxi,ng+1:nyj,ng+1:nzk,lb)     +  &
+!!$           facevarx(1,ng+2:nxc,ng+1:nyj,ng+1:nzk,lb))**2 +  &
+!!$          (facevary(1,ng+1:nxi,ng+1:nyj,ng+1:nzk,lb)     +  &
+!!$           facevary(1,ng+1:nxi,ng+2:nyc,ng+1:nzk,lb))**2 +  &
+!!$          (facevarz(1,ng+1:nxi,ng+1:nyj,ng+1:nzk,lb)     +  &
+!!$           facevarz(1,ng+1:nxi,ng+1:nyj,ng+2:nzc,lb))**2 )               
+
+      solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk) = .5*(            & 
+           (facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk))**2 + &
+           (faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk))**2 + &
+           (facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc))**2 ) 
+
+      ! Sum to turbkin, cell value * cell volume:
+      turbkin = turbkin + & 
+         sum(solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk))*volcell
+
+
+      ! Longitudinal derivatives squared * cell volume: 
+      solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk) = 1.*(                        &
+              (dx**(-1.)*(facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk) -     &
+                        facexData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk)))**2  &
+           +  (dy**(-1.)*(faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk) -     &
+                        faceyData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk)))**2  &
+           +  (dz**(-1.)*(facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc) -     &
+                        facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk)))**2)
+
+
+      varl  = varl + &
+              sum(solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk))*volcell
+
+
+      ! Transverse derivatives squared * cell volume:
+      solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk) = .5*(                        &
+              (dy**(-1.)*(facexData(VELC_FACE_VAR,ng+2:nxc,ng+2:nyc,ng+1:nzk) -      &  ! du/dy**2
+                       facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk)))**2   &
+           +  (dz**(-1.)*(facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+2:nzc) -      &  ! du/dz**2
+                       facexData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+1:nzk)))**2   &           
+           +  (dx**(-1.)*(faceyData(VELC_FACE_VAR,ng+2:nxc,ng+2:nyc,ng+1:nzk) -      &  ! dv/dx**2
+                       faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk)))**2   &
+           +  (dz**(-1.)*(faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+2:nzc) -      &  ! dv/dz**2
+                       faceyData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+1:nzk)))**2   &
+           +  (dx**(-1.)*(facezData(VELC_FACE_VAR,ng+2:nxc,ng+1:nyj,ng+2:nzc) -      &  ! dw/dx**2
+                       facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc)))**2   &
+           +  (dy**(-1.)*(facezData(VELC_FACE_VAR,ng+1:nxi,ng+2:nyc,ng+2:nzc) -      &  ! dw/dy**2
+                       facezData(VELC_FACE_VAR,ng+1:nxi,ng+1:nyj,ng+2:nzc)))**2)                
+
+      vart  = vart + &
+              sum(solnData(DUST_VAR,ng+1:nxi,ng+1:nyj,ng+1:nzk))*volcell
+
+      ! Sum to processors total volume:
+      tvol = tvol + real(NXB*NYB*NZB)*volcell
+
+      ! Release pointers:
+      call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+      call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+      call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+      call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+
+  enddo
+
+  ! Sum to processors total dissipation dissavg = nu * <(dui/dxj)^2>:
+  dissavg = mvisc*(varl + 2. * vart)
+
+  ! Sum processors turbulent dissipation
+  dissavgaux = dissavg
+  call MPI_Allreduce(dissavgaux, dissavg, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr)  
+       
+  ! Sum processors turbulent kinetic energies (q^2):
+  turbkinaux = turbkin
+  call MPI_Allreduce(turbkinaux, turbkin, 1, MPI_DOUBLE_PRECISION,&
+                     MPI_SUM, MPI_COMM_WORLD, ierr)              
+
+  ! Sum processors longitudinal derivatives squared sum:
+  varlaux = varl
+  call MPI_Allreduce(varlaux, varl, 1, MPI_DOUBLE_PRECISION,      &
+                       MPI_SUM, MPI_COMM_WORLD, ierr)              
+
+  ! Sum processors transversal derivatives squared sum:
+  vartaux = vart
+  call MPI_Allreduce(vartaux, vart, 1, MPI_DOUBLE_PRECISION,      &
+                     MPI_SUM, MPI_COMM_WORLD, ierr)    
+
+  ! Sum processors volumes
+  tvolaux = tvol  
+  call MPI_Allreduce(tvolaux, tvol, 1, MPI_DOUBLE_PRECISION,      &
+                     MPI_SUM, MPI_COMM_WORLD, ierr)
+
+  ! Volume Averaged turbulent kinetic energy:
+  turbkin = turbkin/tvol
+
+  ! Volume Averaged longitudinal derivatives squared:
+  dudx_v = varl/(3.*tvol)
+
+  ! Volume Averaged transverse derivatives squared:
+  dudy_v = vart/(3.*tvol)
+
+  ! Longitudinal Taylor Microscale:
+  lambdaf = sqrt(4./3. * turbkin / dudx_v)  ! Uses q^2 = 2*turbkin
+
+  ! Transverse Taylor Microscale:
+  lambdag = sqrt(4./3. * turbkin / dudy_v)  ! Uses q^2 = 2*turbkin
+
+  ! Dissipation eps
+  dissavg = dissavg/tvol 
+
+  ! Scale the forces to forcing the isotropic turbulance
+#ifdef CONST_INPUT_ENG
+  sim_scaleForce = 1.0
+#else
+  sim_scaleForce = sim_turbkin_expect/turbkin
+#endif
+
+  !!!! Remember, Eddy turnover time = turbkin / dissavg !!!!
+  if (mype .eq. 0) then
+
+     if (initfile) then
+
+      OPEN(UNIT=241,FILE='./IOData/TURBKINLAM.res',STATUS='REPLACE', &
+           FORM='formatted')
+      write(241,'(I16,5g20.12)')istep,time,turbkin,lambdaf,lambdag,dissavg
+      write(*,*) &
+      'ISTEP      TIME      TURBKIN        Lambdaf       Lambdag        dissavg'
+      write(*,'(I8,5g14.6)')istep,time,turbkin,lambdaf,lambdag,dissavg
+      close(241)      
+
+      initfile = .FALSE.
+      
+      else
+
+      OPEN(UNIT=241,FILE='./IOData/TURBKINLAM.res',STATUS='OLD',&
+           FORM='formatted',POSITION='APPEND')
+      write(241,'(I16,6g20.12)')istep,time,turbkin,lambdaf,lambdag,dissavg,sim_fbao*sim_scaleForce
+      write(*,*) &
+      'ISTEP      TIME      TURBKIN        Lambdaf       Lambdag        dissavg'
+      write(*,'(I8,5g14.6)')istep,time,turbkin,lambdaf,lambdag,dissavg
+      close(241) 
+
+     endif
+
+  endif
+  ! -------------------------------------------------------------------
+
+  ! Add Mean Velocities: 
+  do lb = 1,blockCount
+     blockID = blockList(lb)
+
+     ! Point to blocks center and face vars:
+     call Grid_getBlkPtr(blockID,facexData,FACEX)
+     call Grid_getBlkPtr(blockID,faceyData,FACEY)
+     call Grid_getBlkPtr(blockID,facezData,FACEZ)
+     
+     facexData(VELC_FACE_VAR,:,:,:) = facexData(VELC_FACE_VAR,:,:,:) + uavg
+     faceyData(VELC_FACE_VAR,:,:,:) = faceyData(VELC_FACE_VAR,:,:,:) + vavg
+     facezData(VELC_FACE_VAR,:,:,:) = facezData(VELC_FACE_VAR,:,:,:) + wavg
+
+     ! Release pointers:
+     call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+     call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+     call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+           
+  enddo
+
+  return
+  end subroutine
+
+
Index: ins_rhs.F90
===================================================================
--- ins_rhs.F90	(revision 0)
+++ ins_rhs.F90	(revision 0)
@@ -0,0 +1,408 @@
+
+      SUBROUTINE ins_rhs2d(uni,vni,ru1,ix1,ix2,jy1,jy2,dx,dy,ru,rv)
+
+  !***************************************************************
+  ! This subroutine computes the discretization of the RHS of the 
+  ! Helmholtz equation on a staggered uniform grid.
+  !
+  ! Input:  uni,vni     = velocity at timestep n
+  !         ru1         = molecular viscosity
+  !         ix1,ix2     = starting and ending x indices
+  !         jy1,jy2     = starting and ending y indices
+  !         dx,dy       = grid spacing in x and y directions
+  !
+  ! Output: ru,rv    = u and v momentum for Helmholtz RHS
+  !**************************************************************
+
+      implicit none
+      INTEGER, INTENT(IN):: ix1, ix2, jy1, jy2
+      REAL, INTENT(IN):: ru1, dx, dy
+      REAL, DIMENSION(:,:,:), INTENT(IN):: uni, vni
+      REAL, DIMENSION(:,:,:), INTENT(OUT):: ru, rv
+
+      INTEGER:: i, j
+      REAL:: dx1, dy1
+      ! x-component variables
+      REAL:: uxplus, uxminus, vxplus, vxminus, wxplus, wxminus, &
+             uyplus, uyminus
+      REAL:: dudxp, dudxm, dudyp, dudym, dvdxp, dvdxm
+      REAL:: tvjp, tvjm
+      REAL:: txxp, txxm, tyyp, tyym
+      REAL:: txyp, txym
+      ! new y-component variables
+      REAL:: vyplus, vyminus
+      REAL:: dvdyp, dvdym
+      REAL:: tvip, tvim
+      INTEGER, parameter :: kz1 = 1
+
+      ! grid spacings
+      dx1 = 1.0/dx
+      dy1 = 1.0/dy
+
+      !++++++++++  U-COMPONENT  ++++++++++
+       do j = jy1,jy2
+          do i = ix1,ix2+1
+             ! get velocities at 1/2 locations
+             uxplus = (uni(i+1,j,kz1) + uni(i,j,kz1))*0.5
+             uxminus = (uni(i,j,kz1) + uni(i-1,j,kz1))*0.5
+
+             vxplus = (vni(i,j+1,kz1) + vni(i-1,j+1,kz1))*0.5
+             vxminus = (vni(i,j,kz1) + vni(i-1,j,kz1))*0.5
+
+             uyplus = (uni(i,j+1,kz1) + uni(i,j,kz1))*0.5
+             uyminus = (uni(i,j,kz1) + uni(i,j-1,kz1))*0.5
+
+             ! get derivatives at 1/2 locations
+             dudxp = (uni(i+1,j,kz1) - uni(i,j,kz1))*dx1
+             dudxm = (uni(i,j,kz1) - uni(i-1,j,kz1))*dx1
+             dudyp = (uni(i,j+1,kz1) - uni(i,j,kz1))*dy1
+             dudym = (uni(i,j,kz1) - uni(i,j-1,kz1))*dy1
+             dvdxp = (vni(i,j+1,kz1) - vni(i-1,j+1,kz1))*dx1
+             dvdxm = (vni(i,j,kz1) - vni(i-1,j,kz1))*dx1
+
+             ! flux of normal total stresses
+             txxp = ru1*dudxp
+             txxm = ru1*dudxm
+             tyyp = ru1*dudyp
+             tyym = ru1*dudym
+
+             ! calculate RHS for u-momentum
+             ru(i,j,kz1) =                                              &
+                          - (uxplus*uxplus - uxminus*uxminus)*dx1       &! advection term
+                          - (vxplus*uyplus - vxminus*uyminus)*dy1       &                          
+                          + (txxp - txxm)*dx1                           &! diffusion - normal terms 
+                          + (tyyp - tyym)*dy1
+          enddo
+       enddo
+
+    !++++++++++  V-COMPONENT  ++++++++++
+
+       do j = jy1,jy2+1
+          do i = ix1,ix2
+             ! get velocities at 1/2 locations
+             vxplus = (vni(i+1,j,kz1) + vni(i,j,kz1))*0.5
+             vxminus = (vni(i,j,kz1) + vni(i-1,j,kz1))*0.5
+
+             vyplus = (vni(i,j+1,kz1) + vni(i,j,kz1))*0.5
+             vyminus = (vni(i,j,kz1) + vni(i,j-1,kz1))*0.5
+
+             uyplus = (uni(i+1,j,kz1) + uni(i+1,j-1,kz1))*0.5
+             uyminus = (uni(i,j,kz1) + uni(i,j-1,kz1))*0.5
+
+             ! get derivatives at 1/2 locations
+             dvdxp = (vni(i+1,j,kz1) - vni(i,j,kz1))*dx1
+             dvdxm = (vni(i,j,kz1) - vni(i-1,j,kz1))*dx1
+             dvdyp = (vni(i,j+1,kz1) - vni(i,j,kz1))*dy1
+             dvdym = (vni(i,j,kz1) - vni(i,j-1,kz1))*dy1
+             dudyp = (uni(i+1,j,kz1) - uni(i+1,j-1,kz1))*dy1
+             dudym = (uni(i,j,kz1) - uni(i,j-1,kz1))*dy1
+
+             ! flux of normal total stresses
+             txxp = ru1*dvdxp
+             txxm = ru1*dvdxm
+             tyyp = ru1*dvdyp
+             tyym = ru1*dvdym
+
+             ! calculate RHS for v-momentum
+             rv(i,j,kz1) =                                              &
+                          - (uyplus*vxplus - uyminus*vxminus)*dx1       &! advection term
+                          - (vyplus*vyplus - vyminus*vyminus)*dy1       &
+                          + (txxp - txxm)*dx1                           &! diffusion - normal terms
+                          + (tyyp - tyym)*dy1
+          enddo
+       enddo
+
+       END SUBROUTINE ins_rhs2d
+
+
+
+
+      SUBROUTINE ins_rhs3d(uni,vni,wni,tv,fau,fav,faw,ru1,      &
+                           ix1,ix2,jy1,jy2,kz1,kz2, &
+                           dx,dy,dz,ru,rv,rw)
+
+  !*****************************************************************
+  ! This subroutine computes the centered discretization of the RHS 
+  ! of the momentum equation (advection + viscous terms) on a 
+  ! staggered uniform grid based on the Paramesh grid structure.
+  !
+  ! Input:  uni,vni,wni = velocity at timestep n
+  !         tv          = eddy viscosity
+  !         ru1         = molecular viscosity
+  !         ix1,ix2     = starting and ending x indices
+  !         jy1,jy2     = starting and ending y indices
+  !         kz1,kz2     = starting and ending z indices
+  !         dx,dy,dz    = grid spacing in x, y, and z directions
+  !
+  ! Output: ru,rv,rw    = RHS of u, v, and w momentum equations
+  !
+  ! E. Balaras   July 1999
+  ! P. Rabenold  August 2006
+  !**************************************************************
+
+      implicit none
+      INTEGER, INTENT(IN):: ix1, ix2, jy1, jy2, kz1, kz2
+      REAL, INTENT(IN):: ru1, dx, dy, dz
+      REAL, DIMENSION(:,:,:), INTENT(IN):: uni, vni, wni, tv, fau, fav, faw
+      REAL, DIMENSION(:,:,:), INTENT(OUT):: ru, rv, rw
+
+!!$      REAL, DIMENSION(nx+1,ny,nz), INTENT(IN):: uni
+!!$      REAL, DIMENSION(nx,ny+1,nz), INTENT(IN):: vni
+!!$      REAL, DIMENSION(nx,ny,nz+1), INTENT(IN):: wni
+!!$      REAL, DIMENSION(nx,ny,nz)  , INTENT(IN):: tv
+!!$
+!!$      REAL, DIMENSION(nx+1,ny,nz), INTENT(OUT):: ru
+!!$      REAL, DIMENSION(nx,ny+1,nz), INTENT(OUT):: rv
+!!$      REAL, DIMENSION(nx,ny,nz+1), INTENT(OUT):: rw
+
+      INTEGER:: i, j, k
+      REAL:: dx1, dy1, dz1
+      ! x-component variables
+      REAL:: uxplus, uxminus, vxplus, vxminus, wxplus, wxminus, &
+             uyplus, uyminus, uzplus, uzminus
+      REAL:: dudxp, dudxm, dudyp, dudym, dudzp, dudzm, dvdxp, dvdxm, &
+             dwdxp, dwdxm
+      REAL:: tvjp, tvjm, tvkp, tvkm
+      REAL:: txxp, txxm, tyyp, tyym, tzzp, tzzm
+      REAL:: txyp, txym, txzp, txzm
+      ! additional y-component variables
+      REAL:: vyplus, vyminus, vzplus, vzminus, wyplus, wyminus
+      REAL:: dvdyp, dvdym, dvdzp, dvdzm, dwdyp, dwdym
+      REAL:: tvip, tvim
+      REAL:: tyzp, tyzm
+      ! additional z-component variables
+      REAL:: wzplus, wzminus
+      REAL:: dwdzp, dwdzm
+
+      ! grid spacings
+      dx1 = 1.0/dx
+      dy1 = 1.0/dy
+      dz1 = 1.0/dz
+
+
+      !++++++++++  U-COMPONENT  ++++++++++
+      do k = kz1,kz2
+         do j = jy1,jy2
+            do i = ix1,ix2+1
+
+               ! get velocities at 1/2 locations
+               uxplus  = (uni(i+1,j  ,k  ) + uni(i  ,j  ,k  ))*0.5
+               uxminus = (uni(i  ,j  ,k  ) + uni(i-1,j  ,k  ))*0.5
+
+               uyplus  = (uni(i  ,j+1,k  ) + uni(i  ,j  ,k  ))*0.5
+               uyminus = (uni(i  ,j  ,k  ) + uni(i  ,j-1,k  ))*0.5
+
+               uzplus  = (uni(i  ,j  ,k+1) + uni(i  ,j  ,k  ))*0.5
+               uzminus = (uni(i  ,j  ,k  ) + uni(i  ,j  ,k-1))*0.5
+
+               vxplus  = (vni(i  ,j+1,k  ) + vni(i-1,j+1,k  ))*0.5
+               vxminus = (vni(i  ,j  ,k  ) + vni(i-1,j  ,k  ))*0.5
+
+               wxplus  = (wni(i  ,j  ,k+1) + wni(i-1,j  ,k+1))*0.5
+               wxminus = (wni(i  ,j  ,k  ) + wni(i-1,j  ,k  ))*0.5
+
+               ! get derivatives at 1/2 locations
+               dudxp = (uni(i+1,j  ,k  ) - uni(i  ,j  ,k  ))*dx1
+               dudxm = (uni(i  ,j  ,k  ) - uni(i-1,j  ,k  ))*dx1
+               dudyp = (uni(i  ,j+1,k  ) - uni(i  ,j  ,k  ))*dy1
+               dudym = (uni(i  ,j  ,k  ) - uni(i  ,j-1,k  ))*dy1
+               dudzp = (uni(i  ,j  ,k+1) - uni(i  ,j  ,k  ))*dz1
+               dudzm = (uni(i  ,j  ,k  ) - uni(i  ,j  ,k-1))*dz1
+               dvdxp = (vni(i  ,j+1,k  ) - vni(i-1,j+1,k  ))*dx1
+               dvdxm = (vni(i  ,j  ,k  ) - vni(i-1,j  ,k  ))*dx1
+               dwdxp = (wni(i  ,j  ,k+1) - wni(i-1,j  ,k+1))*dx1
+               dwdxm = (wni(i  ,j  ,k  ) - wni(i-1,j  ,k  ))*dx1
+
+               ! get nu_t
+
+               !****** requires DIAGONALS for corner ghost cells ******
+
+               tvjp = 0.25*(tv(i-1,j  ,k  ) + tv(i  ,j  ,k  ) + &
+                            tv(i  ,j+1,k  ) + tv(i-1,j+1,k  ))
+               tvjm = 0.25*(tv(i-1,j-1,k  ) + tv(i  ,j-1,k  ) + &
+                            tv(i  ,j  ,k  ) + tv(i-1,j  ,k  ))
+               tvkp = 0.25*(tv(i-1,j  ,k  ) + tv(i  ,j  ,k  ) + &
+                            tv(i  ,j  ,k+1) + tv(i-1,j  ,k+1))
+               tvkm = 0.25*(tv(i-1,j  ,k-1) + tv(i  ,j,  k-1) + &
+                            tv(i  ,j  ,k  ) + tv(i-1,j  ,k  ))
+
+               ! flux of normal total stresses
+               txxp = (ru1 + 2.0*tv(i,j,k))*dudxp
+               txxm = (ru1 + 2.0*tv(i-1,j,k))*dudxm
+               tyyp = (ru1 + tvjp)*dudyp
+               tyym = (ru1 + tvjm)*dudym
+               tzzp = (ru1 + tvkp)*dudzp
+               tzzm = (ru1 + tvkm)*dudzm
+
+               ! flux of cross SGS stresses
+               txyp = tvjp*dvdxp
+               txym = tvjm*dvdxm
+               txzp = tvkp*dwdxp
+               txzm = tvkm*dwdxm
+
+               ! calculate RHS for u-momentum
+               ru(i,j,k) =                                          &                              
+                           - (uxplus*uxplus - uxminus*uxminus)*dx1  &! advection term
+                           - (vxplus*uyplus - vxminus*uyminus)*dy1  &
+                           - (wxplus*uzplus - wxminus*uzminus)*dz1  &             
+                           + (txxp - txxm)*dx1                      &! diffusion - normal terms
+                           + (tyyp - tyym)*dy1                      &
+                           + (tzzp - tzzm)*dz1                      &
+                           + (txyp - txym)*dy1                      &! diffusion - cross terms
+                           + (txzp - txzm)*dz1 + fau(i,j,k)*uni(i,j,k) ! Last term - Linear forcing   
+            enddo
+         enddo
+      enddo
+
+      !++++++++++  V-COMPONENT  ++++++++++
+
+      do k = kz1,kz2
+         do j = jy1,jy2+1
+            do i = ix1,ix2
+
+               ! get velocities at 1/2 locations
+               vxplus  = (vni(i+1,j  ,k  ) + vni(i  ,j  ,k  ))*0.5
+               vxminus = (vni(i  ,j  ,k  ) + vni(i-1,j  ,k  ))*0.5
+
+               vyplus  = (vni(i  ,j+1,k  ) + vni(i  ,j  ,k  ))*0.5
+               vyminus = (vni(i  ,j  ,k  ) + vni(i  ,j-1,k  ))*0.5
+
+               vzplus  = (vni(i  ,j  ,k+1) + vni(i  ,j  ,k  ))*0.5
+               vzminus = (vni(i  ,j  ,k  ) + vni(i  ,j  ,k-1))*0.5
+
+               uyplus  = (uni(i+1,j  ,k  ) + uni(i+1,j-1,k  ))*0.5
+               uyminus = (uni(i  ,j  ,k  ) + uni(i  ,j-1,k  ))*0.5
+
+               wyplus  = (wni(i  ,j  ,k+1) + wni(i  ,j-1,k+1))*0.5
+               wyminus = (wni(i  ,j  ,k  ) + wni(i  ,j-1,k  ))*0.5
+
+               ! get derivatives at 1/2 locations
+               dvdxp = (vni(i+1,j  ,k  ) - vni(i  ,j  ,k  ))*dx1
+               dvdxm = (vni(i  ,j  ,k  ) - vni(i-1,j  ,k  ))*dx1
+               dvdyp = (vni(i  ,j+1,k  ) - vni(i  ,j  ,k  ))*dy1
+               dvdym = (vni(i  ,j  ,k  ) - vni(i  ,j-1,k  ))*dy1
+               dvdzp = (vni(i  ,j  ,k+1) - vni(i  ,j  ,k  ))*dz1
+               dvdzm = (vni(i  ,j  ,k  ) - vni(i  ,j  ,k-1))*dz1
+               dudyp = (uni(i+1,j  ,k  ) - uni(i+1,j-1,k  ))*dy1
+               dudym = (uni(i  ,j  ,k  ) - uni(i  ,j-1,k  ))*dy1
+               dwdyp = (wni(i  ,j  ,k+1) - wni(i  ,j-1,k+1))*dy1
+               dwdym = (wni(i  ,j  ,k  ) - wni(i  ,j-1,k  ))*dy1
+
+               ! get nu_t
+
+               !****** requires DIAGONALS for corner ghost cells ******
+
+               tvip = 0.25*(tv(i  ,j-1,k  ) + tv(i+1,j-1,k  ) + &
+                            tv(i+1,j  ,k  ) + tv(i  ,j  ,k  ))
+               tvim = 0.25*(tv(i-1,j-1,k  ) + tv(i  ,j-1,k  ) + &
+                            tv(i  ,j  ,k  ) + tv(i-1,j  ,k  ))
+               tvkp = 0.25*(tv(i  ,j-1,k  ) + tv(i  ,j-1,k+1) + &
+                            tv(i  ,j  ,k+1) + tv(i  ,j  ,k  ))
+               tvkm = 0.25*(tv(i  ,j-1,k-1) + tv(i  ,j-1,k  ) + &
+                            tv(i  ,j  ,k  ) + tv(i  ,j  ,k-1))
+
+               ! flux of normal total stresses
+               txxp = (ru1 + tvip)*dvdxp
+               txxm = (ru1 + tvim)*dvdxm
+               tyyp = (ru1 + 2.0*tv(i,j,k))*dvdyp
+               tyym = (ru1 + 2.0*tv(i,j-1,k))*dvdym
+               tzzp = (ru1 + tvkp)*dvdzp
+               tzzm = (ru1 + tvkm)*dvdzm
+
+               ! flux of cross SGS stresses
+               txyp = tvip*dudyp
+               txym = tvim*dudym
+               tyzp = tvkp*dwdyp
+               tyzm = tvkm*dwdym
+
+               ! calculate RHS for v-momentum
+               rv(i,j,k) =                                           &
+                           - (uyplus*vxplus - uyminus*vxminus)*dx1   &! advection term
+                           - (vyplus*vyplus - vyminus*vyminus)*dy1   &
+                           - (wyplus*vzplus - wyminus*vzminus)*dz1   &
+                           + (txxp - txxm)*dx1                       &! diffusion - normal terms
+                           + (tyyp - tyym)*dy1                       &
+                           + (tzzp - tzzm)*dz1                       &
+                           + (txyp - txym)*dx1                       &! diffusion - cross terms
+                           + (tyzp - tyzm)*dz1 + fav(i,j,k)*vni(i,j,k) ! Last term - Linear forcing 
+            enddo
+         enddo
+      enddo
+
+      !++++++++++  W-COMPONENT  ++++++++++
+      
+      do k = kz1,kz2+1
+         do j = jy1,jy2
+            do i = ix1,ix2
+
+               ! get velocities at 1/2 locations
+               wxplus  = (wni(i+1,j  ,k  ) + wni(i  ,j  ,k  ))*0.5
+               wxminus = (wni(i  ,j  ,k  ) + wni(i-1,j  ,k  ))*0.5
+               
+               wyplus  = (wni(i  ,j+1,k  ) + wni(i  ,j  ,k  ))*0.5
+               wyminus = (wni(i  ,j  ,k  ) + wni(i  ,j-1,k  ))*0.5
+               
+               wzplus  = (wni(i  ,j  ,k+1) + wni(i  ,j  ,k  ))*0.5
+               wzminus = (wni(i  ,j  ,k  ) + wni(i  ,j  ,k-1))*0.5
+
+               uzplus  = (uni(i+1,j  ,k  ) + uni(i+1,j  ,k-1))*0.5
+               uzminus = (uni(i  ,j  ,k  ) + uni(i  ,j  ,k-1))*0.5
+
+               vzplus  = (vni(i  ,j+1,k  ) + vni(i  ,j+1,k-1))*0.5
+               vzminus = (vni(i  ,j  ,k  ) + vni(i  ,j  ,k-1))*0.5
+
+               ! get derivatives at 1/2 locations
+               dwdxp = (wni(i+1,j  ,k  ) - wni(i  ,j  ,k  ))*dx1
+               dwdxm = (wni(i  ,j  ,k  ) - wni(i-1,j  ,k  ))*dx1
+               dwdyp = (wni(i  ,j+1,k  ) - wni(i  ,j  ,k  ))*dy1
+               dwdym = (wni(i  ,j  ,k  ) - wni(i  ,j-1,k  ))*dy1
+               dwdzp = (wni(i  ,j  ,k+1) - wni(i  ,j  ,k  ))*dz1
+               dwdzm = (wni(i  ,j  ,k  ) - wni(i  ,j  ,k-1))*dz1
+               dudzp = (uni(i+1,j  ,k  ) - uni(i+1,j  ,k-1))*dz1
+               dudzm = (uni(i  ,j  ,k  ) - uni(i  ,j  ,k-1))*dz1
+               dvdzp = (vni(i  ,j+1,k  ) - vni(i  ,j+1,k-1))*dz1
+               dvdzm = (vni(i  ,j  ,k  ) - vni(i  ,j  ,k-1))*dz1
+
+               ! get nu_t
+
+               !****** requires DIAGONALS for corner ghost cells ******
+
+               tvip = 0.25*(tv(i  ,j  ,k-1) + tv(i+1,j  ,k-1) + &
+                            tv(i+1,j  ,k  ) + tv(i  ,j  ,k  ))
+               tvim = 0.25*(tv(i-1,j  ,k-1) + tv(i  ,j  ,k-1) + &
+                            tv(i  ,j  ,k  ) + tv(i-1,j  ,k  ))
+               tvjp = 0.25*(tv(i  ,j  ,k-1) + tv(i  ,j  ,k  ) + &
+                            tv(i  ,j+1,k  ) + tv(i  ,j+1,k-1))
+               tvjm = 0.25*(tv(i  ,j-1,k-1) + tv(i  ,j-1,k  ) + & 
+                            tv(i  ,j  ,k  ) + tv(i  ,j  ,k-1))
+
+               ! flux of normal total stresses
+               txxp = (ru1 + tvip)*dwdxp
+               txxm = (ru1 + tvim)*dwdxm
+               tyyp = (ru1 + tvjp)*dwdyp
+               tyym = (ru1 + tvjm)*dwdym
+               tzzp = (ru1 + 2.0*tv(i,j,k))*dwdzp
+               tzzm = (ru1 + 2.0*tv(i,j,k-1))*dwdzm
+
+               ! flux of cross SGS stresses
+               txzp = tvip*dudzp
+               txzm = tvim*dudzm
+               tyzp = tvjp*dvdzp
+               tyzm = tvjm*dvdzm
+
+               ! calculate RHS for w-momentum
+               rw(i,j,k) =                                          &
+                          - (uzplus*wxplus - uzminus*wxminus)*dx1   &! advection term
+                          - (vzplus*wyplus - vzminus*wyminus)*dy1   &
+                          - (wzplus*wzplus - wzminus*wzminus)*dz1   &
+                          + (txxp - txxm)*dx1                       &! diffusion - normal terms
+                          + (tyyp - tyym)*dy1                       &
+                          + (tzzp - tzzm)*dz1                       &
+                          + (txzp - txzm)*dx1                       &! diffusion - cross terms
+                          + (tyzp - tyzm)*dy1 + faw(i,j,k)*wni(i,j,k) ! Last term - Linear forcing                       
+            enddo
+         enddo
+      enddo
+
+      END SUBROUTINE ins_rhs3d
+
Index: ins_exportBlock.F90
===================================================================
--- ins_exportBlock.F90	(revision 0)
+++ ins_exportBlock.F90	(revision 0)
@@ -0,0 +1,104 @@
+! Modified from subroutine ins_exportslices_z
+! Explorts flow information for  turbulence simulations:
+! One file will be written per bloci.
+! Shizhao Wang
+! Dec 05, 2014
+! --------------------------------------------------------------------------
+
+  subroutine ins_exportBlock(istep,iwrite,time,mvisc,blockCount,blockList)
+
+  ! Modules Use:
+  use Grid_interface, ONLY : Grid_getDeltas,         &
+                             Grid_getBlkCenterCoords,&
+                             Grid_getBlkPhysicalSize,&
+                             Grid_getBlkBoundBox,    &
+                             Grid_getBlkBC,          &
+                             Grid_getBlkPtr,         &
+                             Grid_releaseBlkPtr,     &
+                             Grid_getBlkIndexLimits, &
+                             Grid_getBlkCornerID,    &
+                             Grid_getGlobalIndexLimits
+
+  
+!  use ins_interface, only  :  ins_velomg2center
+  
+  use Grid_data, only : gr_meshMe, gr_meshNumProcs, gr_meshComm, gr_imin, gr_imax, gr_jmin, gr_jmax, gr_kmin, gr_kmax
+  
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get
+
+  implicit none
+#include "constants.h"
+#include "Flash.h"
+#include "Flash_mpi.h"
+#include "IncompNS.h"
+
+  integer :: istep, iwrite
+  real    :: time, mvisc
+  integer, INTENT(IN) :: blockCount
+  integer, INTENT(IN), dimension(blockCount) :: blockList
+
+  real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+  
+  real :: del(MDIM),coord(MDIM)
+
+  integer i,j,k,lb,blockID
+
+  character(80) :: filename
+  integer :: ixs, ixe, iys, iye, izs, ize
+
+  integer :: iFile
+
+#ifdef FLASH_GRID_PARAMESH
+  write(*,*) 'The routine ins_exportZone has not been tested for the ParaMesh.'
+  write(*,*) 'The routine ins_exportZone just allows one block per procs..'
+  stop
+#endif
+
+  ixs = NGUARD + 1
+  ixe = NGUARD + NXB
+  iys = NGUARD + 1
+  iye = NGUARD + NYB
+  izs = NGUARD + 1
+  ize = NGUARD + NZB
+
+  do lb = 1,blockCount
+      blockID = blockList(lb)
+ 
+      ! Get blocks dx, dy ,dz:
+      call Grid_getDeltas(blockID,del)
+ 
+      ! Point to blocks center and face vars:
+      call Grid_getBlkPtr(blockID,solnData,CENTER)
+      call Grid_getBlkPtr(blockID,facexData,FACEX)
+      call Grid_getBlkPtr(blockID,faceyData,FACEY)
+      call Grid_getBlkPtr(blockID,facezData,FACEZ)
+
+      write(filename,'("./IOData/stat_block.",i4.4,".",i6.6,".bin")') &
+                     iwrite, gr_meshMe  
+      iFile = 51000000+gr_meshMe
+      open(iFile,file=trim(filename),status='replace',form='unformatted')
+
+        write(iFile) time,mvisc
+        write(iFile) istep, NXB, NYB, NZB
+        write(iFile) del
+        write(iFile) gr_imin,gr_imax,gr_jmin,gr_jmax, gr_kmin, gr_kmax
+
+        write(iFile)  (((solnData(PRES_VAR,i,j,k), i=ixs,ixe),j=iys,iye),k=izs,ize) 
+        write(iFile)  (((facexData(VELC_FACE_VAR,i,j,k), i=ixs,ixe+1),j=iys,iye),k=izs,ize) 
+        write(iFile)  (((faceyData(VELC_FACE_VAR,i,j,k), i=ixs,ixe),j=iys,iye+1),k=izs,ize) 
+        write(iFile)  (((facezData(VELC_FACE_VAR,i,j,k), i=ixs,ixe),j=iys,iye),k=izs,ize+1) 
+
+      close(iFile)
+
+      call Grid_releaseBlkPtr(blockID,solnData,CENTER)
+      call Grid_releaseBlkPtr(blockID,facexData,FACEX)
+      call Grid_releaseBlkPtr(blockID,faceyData,FACEY)
+      call Grid_releaseBlkPtr(blockID,facezData,FACEZ)
+ 
+   enddo
+
+  return
+  end subroutine ins_exportBlock
+
+
+
Index: Simulation_init.F90
===================================================================
--- Simulation_init.F90	(revision 0)
+++ Simulation_init.F90	(revision 0)
@@ -0,0 +1,57 @@
+!!****if* source/Simulation/SimulationMain/INavierStokes/3D/ChannelLam/Simulation_init
+!!
+!! NAME
+!!
+!!  Simulation_init
+!!
+!!
+!! SYNOPSIS
+!!
+!!  Simulation_init()
+!!
+!! ARGUMENTS
+!!
+!!   
+!!
+!! DESCRIPTION
+!!
+!!  Initializes all the data specified in Simulation_data.
+!!  It calls RuntimeParameters_get rotuine for initialization.
+!!  Initializes initial conditions for INS-isotropic turbulence problem.
+!!
+!!***
+
+subroutine Simulation_init()
+
+  use Simulation_data, ONLY : sim_xMin, sim_yMin, sim_zMin, &
+                              sim_xMax, sim_yMax, sim_zMax, sim_gCell, &
+                              sim_fbao, sim_turbkin_expect, sim_scaleForce
+
+  use RuntimeParameters_interface, ONLY : RuntimeParameters_get
+
+  use Grid_data, only : gr_meshMe
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+
+  
+
+  call RuntimeParameters_get('xmin',    sim_xMin)
+  call RuntimeParameters_get('ymin',    sim_yMin)
+  call RuntimeParameters_get('zmin',    sim_zMin)
+  call RuntimeParameters_get('xmax',    sim_xMax)
+  call RuntimeParameters_get('ymax',    sim_yMax)
+  call RuntimeParameters_get('zmax',    sim_zMax)
+
+  sim_gCell = .true.
+
+  call RuntimeParameters_get('sim_fbao', sim_fbao)
+  call RuntimeParameters_get('sim_turbkin_expect', sim_turbkin_expect)
+  call RuntimeParameters_get('sim_scaleForce', sim_scaleForce)
+  if(gr_meshMe == MASTER_PE) write(*,*) 'Forced turbulence, FBAO=', sim_fbao
+  if(gr_meshMe == MASTER_PE) write(*,*) 'Expected tke =', sim_turbkin_expect
+  if(gr_meshMe == MASTER_PE) write(*,*) 'Initial force scalor =', sim_scaleForce
+
+end subroutine Simulation_init
Index: Config
===================================================================
--- Config	(revision 0)
+++ Config	(revision 0)
@@ -0,0 +1,47 @@
+#       Configuration file for Laminar Channel Problem.
+#	Config file for the INS module.
+#       Note: This is a staggered finite difference mesh algorithm.
+USESETUPVARS Grid
+REQUIRES physics/IncompNS/IncompNSMain/constdens
+REQUIRES physics/IncompNS/IncompNSMain/extras
+#REQUIRES physics/IncompNS/IncompNSMain/stats
+
+# Tecplot output:
+#REQUIRES Simulation/SimulationMain/INavierStokes/3D/Tecplot3D/Slices
+REQUIRES Simulation/SimulationMain/INavierStokes/3D/Tecplot3D
+
+# Poisson Solver
+IF Grid=='UG'
+   REQUESTS Grid/GridSolvers/Pfft/HomBcTrigSolver
+#HomBcTrigSolver
+#DirectSolver/Generic_Direct
+ELSE
+   REQUIRES Simulation/SimulationMain/INavierStokes/paramesh_routines
+   REQUESTS Grid/GridSolvers/MultigridMC/poisson/PfftTopLevelSolve/HomBcTrig
+#   REQUESTS Grid/GridSolvers/Multigrid/PfftTopLevelSolve
+#   REQUESTS Grid/GridSolvers/MultigridMC/poisson/PfftTopLevelSolve
+#   REQUESTS Grid/GridSolvers/BiPCGStab/poisson/PrecondMultigrid
+ENDIF
+
+# ----------------------------------------------
+# THIS PART IS FOR PROBLEM DEPENDENT CONFIG FILE
+FACEVAR fbao
+FACEVAR uprm
+
+PARAMETER sim_fbao  REAL 0.0
+PARAMETER sim_turbkin_expect  REAL 0.0
+PARAMETER sim_scaleForce  REAL 1.0
+# Compute stats vs time and write every nstatsz steps:
+PARAMETER nstatsz                 INTEGER     1000 
+
+PARAMETER stats_slicesz_from_file BOOLEAN    false
+PARAMETER stats_nslicesz          INTEGER        0
+
+
+# ----------------------------------------------
+
+# Number of guardcells at each boundary
+GUARDCELLS 2
+
+
+
Index: ins_interface.F90
===================================================================
--- ins_interface.F90	(revision 0)
+++ ins_interface.F90	(revision 0)
@@ -0,0 +1,273 @@
+!!****if* source/physics/IncompNS/IncompNSMain/constdens/ins_interface
+!!
+!! NAME
+!!  
+!!
+!! SYNOPSIS
+!!  ins_interface()
+!!
+!! DESCRIPTION
+!!  This is an interface specific for the Incompressible Navier Stokes
+!!  module that defines its public interfaces.
+!!
+!!***
+Module ins_interface
+
+  implicit none
+
+#include "constants.h"
+#include "Flash.h"
+#include "IncompNS.h"
+
+
+  ! Routines:
+  ! ins_computeDtLocal
+  ! ins_ab2rk3.F90
+  ! ins_advance.F90
+  ! ins_fluxes.F90
+  ! ins_rhs.F90
+  ! ins_vt.F90
+  ! ins_velomg2center.F90 (Found in extras directory one level up)
+
+
+  interface 
+
+    subroutine ins_computeDtLocal(blockID,   & 
+                          isize, jsize, ksize,  &
+                          dx, dy, dz,           &
+                          blkLimits,blkLimitsGC,&
+                          facexData,faceyData,  &
+                          facezData,            &
+                          dtLocal, lminloc)
+      implicit none
+      integer, intent(IN) :: blockID
+      integer,dimension(2,MDIM), intent(IN) :: blkLimits,blkLimitsGC
+      integer :: isize,jsize,ksize
+      real :: dx, dy, dz
+      real, intent(INOUT) :: dtLocal
+      integer, intent(INOUT) :: lminloc(5)
+      real, pointer,dimension(:,:,:,:)  :: facexData,faceyData,facezData
+    end subroutine ins_computeDtLocal
+
+  end interface
+
+
+
+  interface
+     subroutine ins_ab2rk3( blockCount, blockList, timeEndAdv, dt)
+       implicit none
+       !! ---- Argument List ----------------------------------
+       integer, INTENT(INOUT) ::  blockCount
+       integer, INTENT(INOUT), dimension(MAXBLOCKS) :: blockList
+       real,    INTENT(IN) :: timeEndAdv,dt
+       !! -----------------------------------------------------
+     end subroutine ins_ab2rk3
+  end interface
+
+
+  interface
+
+      SUBROUTINE ins_predictor(uni,vni,wni,unew,vnew,wnew,uold,vold,&
+        wold,p,dt,dx,dy,dz,ix1,ix2,jy1,jy2,kz1,kz2,gama,rhoa,alfa)
+      implicit none 
+      INTEGER, INTENT(IN) :: ix1,ix2,jy1,jy2,kz1,kz2
+      REAL, INTENT(IN) :: dt,dx,dy,dz
+      REAL, DIMENSION(:,:,:), INTENT(IN) :: unew,vnew,wnew,&
+                                            uold,vold,wold,&
+                                            p
+      REAL, DIMENSION(:,:,:), INTENT(IN OUT) :: uni,vni,wni
+      REAL :: gama,rhoa,alfa
+      END SUBROUTINE ins_predictor
+
+      SUBROUTINE ins_divergence(uni,vni,wni,ix1,ix2,jy1,jy2,kz1,kz2,&
+         dx,dy,dz,divv)
+      implicit none
+      INTEGER, INTENT(IN) :: ix1,ix2,jy1,jy2,kz1,kz2
+      REAL, INTENT(IN) :: dx,dy,dz
+      REAL, DIMENSION(:,:,:), INTENT(IN) :: uni,vni,wni
+      REAL, DIMENSION(:,:,:), INTENT(OUT) :: divv
+      END SUBROUTINE ins_divergence
+
+      SUBROUTINE ins_corrector(uni,vni,wni,p,ix1,ix2,jy1,jy2,kz1,kz2, &
+        dt,dx,dy,dz,alfa)
+      implicit none
+      INTEGER, INTENT(IN) :: ix1,ix2,jy1,jy2,kz1,kz2
+      REAL, INTENT(IN) :: dt,dx,dy,dz,alfa
+      REAL, DIMENSION(:,:,:), INTENT(IN) :: p
+      REAL, DIMENSION(:,:,:), INTENT(IN OUT) :: uni,vni,wni
+      END SUBROUTINE ins_corrector
+
+  end interface
+
+
+  interface
+
+     SUBROUTINE ins_fluxfix(ng,nxc,nyc,nzc,nxi,nyj,nzk,blockCount,&
+                            blockList)
+     implicit none
+     integer, intent(IN) :: ng,nxc,nyc,nzc,nxi,nyj,nzk, &
+                            blockCount     
+     integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+     end SUBROUTINE ins_fluxfix
+
+     SUBROUTINE ins_fluxfix_p(ng,nxc,nyc,nzc,nxi,nyj,nzk,pvar, &
+                              blockCount,blockList)
+     implicit none
+     integer, intent(in) :: ng,nxc,nyc,nzc,nxi,nyj,nzk,pvar,&
+                            blockCount
+     integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+     end SUBROUTINE ins_fluxfix_p
+
+  end interface
+
+  interface
+
+      SUBROUTINE ins_rhs3d(uni,vni,wni,tv,fau,fav,faw,ru1,ix1,ix2,jy1,jy2,kz1,kz2,&
+                         dx,dy,dz,ru,rv,rw) 
+      implicit none
+      INTEGER, INTENT(IN):: ix1, ix2, jy1, jy2, kz1, kz2
+      REAL, INTENT(IN):: ru1, dx, dy, dz
+      REAL, DIMENSION(:,:,:), INTENT(IN):: uni, vni, wni, tv, fau,fav,faw
+      REAL, DIMENSION(:,:,:), INTENT(OUT):: ru, rv, rw
+      end SUBROUTINE ins_rhs3d
+
+
+      SUBROUTINE ins_rhs2d(uni,vni,ru1,ix1,ix2,jy1,jy2,dx,dy,ru,rv)
+      implicit none
+      INTEGER, INTENT(IN):: ix1, ix2, jy1, jy2
+      REAL, INTENT(IN):: ru1, dx, dy
+      REAL, DIMENSION(:,:,:), INTENT(IN):: uni, vni
+      REAL, DIMENSION(:,:,:), INTENT(OUT):: ru, rv
+      end SUBROUTINE ins_rhs2d
+
+
+  end interface
+
+
+  interface
+
+     SUBROUTINE ins_vt(isgs,ng,nxc,nyc,nzc,RU1,dx,dy,dz,   &
+                    coord,bsize,&
+                    facexData,&
+                    faceyData,&
+                    facezData,&
+                    solnData)             
+
+       implicit none
+       integer isgs,ng,nxc,nyc,nzc
+       real  RU1,dx,dy,dz       
+       real coord(3),bsize(3)
+
+       real, pointer, dimension(:,:,:,:) :: solnData, facexData,faceyData,facezData
+     END SUBROUTINE ins_vt
+
+  end interface
+
+
+  interface
+
+      subroutine ins_velgradtensor(ng,facevarxx,facevaryy,facevarzz, &
+                 dx,dy,dz,tpdudxc,tpdudyc,tpdudzc,       &
+                 tpdvdxc,tpdvdyc,tpdvdzc,tpdwdxc,tpdwdyc,tpdwdzc)
+     
+      implicit none
+      integer ng     
+      real dx,dy,dz
+      real, pointer, dimension(:,:,:,:) :: facevarxx,facevaryy,facevarzz
+
+      real, dimension(NXB+2*ng,NYB+2*ng,NZB+2*ng) :: tpdudxc,&
+             tpdudyc,tpdudzc,tpdvdxc,tpdvdyc,tpdvdzc,tpdwdxc,&
+             tpdwdyc,tpdwdzc
+
+      end subroutine ins_velgradtensor
+
+   end interface
+
+   interface
+
+      subroutine ins_setInterpValsGcell(setval)
+      logical, intent(IN) :: setval
+      end subroutine ins_setInterpValsGcell
+
+   end interface
+
+   interface
+
+      subroutine ins_computeQinout( blockCount, blockList, inou_flg,  Qinout)
+        implicit none
+        integer, INTENT(IN) :: blockCount
+        integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+        logical, INTENT(IN) :: inou_flg
+        real,    INTENT(OUT) :: Qinout
+      end subroutine
+
+   end interface
+
+   interface
+
+      subroutine ins_rescaleVelout( blockCount, blockList, Qin,  Qout)
+        implicit none
+        integer, INTENT(IN) :: blockCount
+        integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+        real,    INTENT(IN) :: Qin, Qout
+      end subroutine
+
+   end interface
+
+   interface
+
+      subroutine ins_convectVelout( blockCount, blockList, convvel)
+        implicit none
+        integer, INTENT(IN) :: blockCount
+        integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+        real,    INTENT(OUT) :: convvel(LOW:HIGH,MDIM)
+      end subroutine
+
+   end interface
+
+   interface
+     subroutine ins_velomg2center( blockList, blockCount)
+       implicit none
+       !! ---- Argument List ----------------------------------
+       integer, INTENT(IN) ::  blockCount
+       integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList
+       !! -----------------------------------------------------
+     end subroutine ins_velomg2center
+   end interface
+
+   interface
+      subroutine ins_UstarStats( blockCount, blockList, print_flg, qin_flg)
+        implicit none
+        !! ---- Argument List ----------------------------------
+        integer, INTENT(IN) :: blockCount
+        integer, INTENT(IN), dimension(MAXBLOCKS) :: blockList 
+        logical, INTENT(IN) :: print_flg, qin_flg
+        !! -----------------------------------------------------
+      end subroutine ins_UstarStats
+
+   end interface
+
+   interface
+
+      subroutine ins_pressgradients(time,dt)
+        implicit none
+        !! ---- Argument List ----------------------------------
+        real, intent(in) :: time, dt
+        !! -----------------------------------------------------
+      end subroutine ins_pressgradients
+
+   end interface
+
+   
+   interface 
+
+      subroutine ins_getBulkVelocity(velB,myaxis)
+        implicit none
+        real, intent(out) :: velB
+        integer, intent(in) :: myaxis
+      end subroutine ins_getBulkVelocity
+
+   end interface
+
+
+ end Module ins_interface
Index: interpvars_face.F90
===================================================================
--- interpvars_face.F90	(revision 0)
+++ interpvars_face.F90	(revision 0)
@@ -0,0 +1,328 @@
+! Subroutine interpvars_face:
+! Subroutine that interpolates values to a given given block
+!
+! Written by Marcos Vanella, December 2006
+! --------------------------------------------------------------
+
+!!#define RESCALE_LOCATION 1
+
+subroutine interpvars_face(ng,nxb,nyb,nzb,coord,bsize,&
+                           nxvar,nyvar,nzvar,xvar,yvar,zvar,&
+                           Var0,nx1,ny1,nz1,blkvar,gridflag)
+
+
+  use Grid_data, only : gr_imax,gr_imin,gr_jmax,gr_jmin,gr_kmax,gr_kmin
+
+  implicit none
+#include "constants.h"
+      
+  integer ng,nxb,nyb,nzb,nxvar,nyvar,nzvar, &
+         nx1,ny1,nz1,gridflag
+
+  real coord(3),bsize(3),Var0(nxvar,nyvar,nzvar),&
+      xvar(nxvar),yvar(nyvar),zvar(nzvar),&
+      blkvar(nx1,ny1,nz1)
+
+
+  ! Local Variables:
+  integer, parameter :: stencil    = 8
+  integer, parameter :: interptype = 2  ! =1 MLS, =2 8 node fem interp. functions
+  integer, parameter :: interp     = 1
+  integer, parameter :: npol       = 4
+  integer, parameter :: nderiv     = 4
+
+
+  integer buildflag
+  real dsx,dsy,dsz
+  real A(npol,npol,nderiv), B(npol,stencil,nderiv)
+  real p(npol,nderiv), phi(stencil,nderiv), &
+      gamma(npol,nderiv), indx(npol)
+
+  real xs(stencil),ys(stencil),zs(stencil)
+  integer ielem(stencil),jelem(stencil),kelem(stencil)
+  real dx,dy,dz,dxaux,dyaux,dzaux,xi,yj,zk
+  integer i,j,k,ii,jj,kk,icell,jcell,kcell
+  integer is
+
+  real*8 zp,d
+  real*8 sitan,etan,xin
+
+  logical :: wrxflg 
+  logical :: wryflg 
+  logical :: wrzflg 
+
+  logical :: inject = .false. !.true.
+
+  real*8 distx,disty,distz
+
+  real :: maxsizeL
+
+  real, parameter :: eps = 1.e-10
+
+  !------------------------------------------------------------------------------ 
+  wrxflg = .true.
+  wryflg = .true.
+  wrzflg = .true.
+      
+  ! stencil to use in the interpolation
+  dx = bsize(1)/real(nxb)
+  dy = bsize(2)/real(nyb)
+  dz = bsize(3)/real(nzb)
+
+!!$  write(*,*) 'dx,dy,dz=',dx,dy,dz
+
+  select case (gridflag)
+  case(1)
+     dxaux = 0.0
+     dyaux = 0.5*dy
+     dzaux = 0.5*dz
+  case(2)
+     dxaux = 0.5*dx
+     dyaux = 0.0
+     dzaux = 0.5*dz
+  case(3)
+     dxaux = 0.5*dx
+     dyaux = 0.5*dy
+     dzaux = 0.0
+  end select
+      
+
+  ! Initialize the variable to zero:
+  blkvar = 0.
+
+
+  do k = ng+1,nz1-ng
+     do j = ng+1,ny1-ng
+        do i = ng+1,nx1-ng
+
+#ifndef RESCALE_LOCATION
+           ! Position of block point i,j,k
+           xi = coord(1) - 0.5*bsize(1) + &
+                real(i - ng - 1)*dx + dxaux
+
+           yj = coord(2) - 0.5*bsize(2) + &
+                real(j - ng - 1)*dy + dyaux
+
+           zk = coord(3) - 0.5*bsize(3) + &
+                real(k - ng - 1)*dz + dzaux                  
+#else
+           maxsizeL = max((gr_imax-gr_imin),(gr_jmax-gr_jmin),(gr_kmax-gr_kmin))
+
+           ! Rescale:
+           ! Position of block point i,j,k
+           xi = (coord(1) - 0.5*bsize(1) + &
+                real(i - ng - 1)*dx + dxaux)*2.*PI/maxsizeL
+
+           yj = (coord(2) - 0.5*bsize(2) + &
+                real(j - ng - 1)*dy + dyaux)*2.*PI/maxsizeL
+
+           zk = (coord(3) - 0.5*bsize(3) + &
+                real(k - ng - 1)*dz + dzaux)*2.*PI/maxsizeL ! - PI/2.
+#endif
+
+
+
+!!$           if (gridflag .eq. 1 .and. &
+!!$               k .eq. ng+2     .and. &
+!!$               j .eq. ng+2     .and. &
+!!$               i .eq. ng+1+2    ) then
+!!$             
+!!$           write(*,*) 'Guardcells',ng
+!!$           
+!!$           write(*,*) 'Uposition, 2,2,2=', &
+!!$                       xi,yj,zk
+!!$
+!!$           endif
+
+               
+           if (inject) then
+
+               ! Now Find the enclosing cell from the Var0 grid:
+               icell = 0; jcell = 0; kcell = 0;
+               distx = 1.e30; disty = 1.e30;  distz = 1.e30; 
+
+               if ( (xi .gt. (PI+eps)) ) then
+                  xi = xi - 2.*PI 
+               elseif ( (xi .lt. -(PI+eps)) ) then
+                  xi = xi + 2.*PI
+               endif
+
+               do ii = 1,nxvar-1
+                  if( abs(xvar(ii)-xi) .le. distx) then
+                    icell = ii
+                    distx = abs(xvar(ii)-xi)
+                  endif
+               enddo
+
+               if ( (yj .gt. (PI+eps)) ) then
+                  yj = yj - 2.*PI
+               elseif ( (yj .lt. -(PI+eps)) ) then
+                  yj = yj + 2.*PI
+               endif               
+
+               do jj = 1,nyvar-1
+                  if( abs(yvar(jj)-yj) .le. disty) then
+                    jcell = jj
+                    disty = abs(yvar(jj)-yj)
+                  endif
+               enddo
+
+               do kk = 1,nzvar-1
+                  if( abs(zvar(kk)-zk) .le. distz) then
+                    kcell = kk
+                    distz = abs(zvar(kk)-zk)
+                  endif
+               enddo
+
+
+           else
+
+               ! Now Find the enclosing cell from the Var0 grid:
+               icell = 0; jcell = 0; kcell = 0;
+               do ii = 1,nxvar-1
+                  if( xvar(ii) .le. xi .and. xvar(ii+1) .ge. xi) then
+                    icell = ii
+                    goto 10
+                  endif
+               enddo
+ 10            continue
+
+               do jj = 1,nyvar-1
+                  if( yvar(jj) .le. yj .and. yvar(jj+1) .ge. yj) then
+                    jcell = jj
+                    goto 11
+                  endif
+               enddo
+ 11            continue              
+
+               do kk = 1,nzvar-1
+                  if( zvar(kk) .le. zk .and. zvar(kk+1) .ge. zk) then
+                    kcell = kk
+                    goto 12
+                  endif
+               enddo
+ 12            continue  
+
+           endif
+
+           if (icell .eq. 0 .or. jcell  .eq. 0 .or. kcell .eq. 0) then
+
+               write(*,*) 'Error in interpolation of values:'
+               write(*,*) 'Gridflag = ',gridflag
+               write(*,*) 'Icell,Jcell,Kcell =',icell,jcell,kcell
+               write(*,*) 'Block Point coordinates:'
+               write(*,*) xi,yj,zk
+               stop
+                
+           endif
+
+           ielem = (/ icell+1,icell+1,icell,icell,&
+                     icell+1,icell+1,icell,icell /)               
+
+           jelem = (/ jcell,jcell+1,jcell+1,jcell,&
+                     jcell,jcell+1,jcell+1,jcell /)
+
+           kelem = (/ kcell,kcell,kcell,kcell,&
+                     kcell+1,kcell+1,kcell+1,kcell+1/)
+
+           do is=1,stencil
+              xs(is) = xvar(ielem(is))
+              ys(is) = yvar(jelem(is))
+              zs(is) = zvar(kelem(is))
+           enddo
+
+!!$           xs = xvar(ielem)
+!!$           ys = yvar(jelem)
+!!$           zs = zvar(kelem)
+
+               
+           if (inject) then
+
+              if((zk .lt. -(PI+eps)) .or. (zk .gt. (PI+eps))) cycle 
+
+              zp = Var0(icell,jcell,kcell)
+
+           else
+
+              if (interptype .eq. 1) then
+
+                 ! Having found the cell interpolate:
+                 dsx = 1.2*(xvar(icell+1)-xvar(icell))
+                 dsy = 1.2*(yvar(jcell+1)-yvar(jcell))
+                 dsz = 1.2*(zvar(kcell+1)-zvar(kcell))
+
+
+                 ! Build A and B matrices:
+!                 call buildABLan(stencil,interp,npol,nderiv,dsx,&
+!                dsy,dsz,xi,yj,zk,xs,ys,zs,A,B,buildflag, 0 );
+
+
+                 p(1,1) = 1.; p(2,1) = xi; p(3,1) = yj; p(4,1) = zk; !  p
+
+
+                 ! Solve for gamma:
+                 gamma(:,1) = p(:,1)
+
+!                 call ludcmp(A(:,:,1),npol,npol,indx,d)
+!                 call lubksb(A(:,:,1),npol,npol,indx,gamma(:,1))
+
+                 ! Obtain Shape functions:
+                 phi(:,1) =0.
+                 do ii = 1 , stencil
+                  do jj = 1, npol
+                     phi(ii,1) = phi(ii,1) + gamma(jj,1)*B(jj,ii,1)
+                  enddo
+                 enddo                            
+
+                 ! Value of the function in xp and yp:
+                 zp = 0.;
+                 do ii = 1 , stencil      
+                  zp = zp + phi(ii,1)*&
+                      Var0(ielem(ii),jelem(ii),kelem(ii));   
+                 enddo   
+
+
+               else
+
+                 ! Having found the cell interpolate:
+                 dsx = (xvar(icell+1)-xvar(icell))
+                 dsy = (yvar(jcell+1)-yvar(jcell))
+                 dsz = (zvar(kcell+1)-zvar(kcell))
+
+
+                 ! Natural coordinates (from -1 to 1) for rectangle:
+                 sitan = -1. + (xi - xs(4))/dsx * 2.
+                 etan  = -1. + (yj - ys(4))/dsy * 2.
+                 xin   = -1. + (zk - zs(4))/dsz * 2.   
+
+                 ! shape functions:
+                 phi(1,1) = (1.+sitan)*(1.-etan)*(1-xin)/8. 
+                 phi(2,1) = (1.+sitan)*(1.+etan)*(1-xin)/8.
+                 phi(3,1) = (1.-sitan)*(1.+etan)*(1-xin)/8.
+                 phi(4,1) = (1.-sitan)*(1.-etan)*(1-xin)/8.
+                 phi(5,1) = (1.+sitan)*(1.-etan)*(1+xin)/8.
+                 phi(6,1) = (1.+sitan)*(1.+etan)*(1+xin)/8.
+                 phi(7,1) = (1.-sitan)*(1.+etan)*(1+xin)/8.
+                 phi(8,1) = (1.-sitan)*(1.-etan)*(1+xin)/8.
+              
+
+                 ! value of the function in xi, yj, zk:         
+                 zp = 0.;
+                 do ii = 1 , stencil      
+                  zp = zp + phi(ii,1)*&
+                      Var0(ielem(ii),jelem(ii),kelem(ii));   
+                 enddo    
+
+              endif
+
+           endif
+
+           blkvar(i,j,k) = zp; 
+
+        enddo
+     enddo
+  enddo
+
+  return
+
+end subroutine interpvars_face
Index: ISOTURB_files/ICdata/64x64x64.res
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: ISOTURB_files/ICdata/64x64x64.res
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: ISOTURB_files/ICdata/64x64x64.grd
===================================================================
--- ISOTURB_files/ICdata/64x64x64.grd	(revision 0)
+++ ISOTURB_files/ICdata/64x64x64.grd	(revision 0)
@@ -0,0 +1,300 @@
+   1     65
+   1     65
+   1     65
+     0.1000E+01     0.1000E+01     0.1000E+01
+           0.000000000000000E+00           9.817477042187500E-02           1.963495408437500E-01           2.945243112656250E-01           3.926990816875000E-01
+           4.908738521093750E-01           5.890486225312500E-01           6.872233929531251E-01           7.853981633750000E-01           8.835729337968750E-01
+           9.817477042187499E-01           1.079922474640625E+00           1.178097245062500E+00           1.276272015484375E+00           1.374446785906250E+00
+           1.472621556328125E+00           1.570796326750000E+00           1.668971097171875E+00           1.767145867593749E+00           1.865320638015624E+00
+           1.963495408437499E+00           2.061670178859374E+00           2.159844949281249E+00           2.258019719703124E+00           2.356194490124999E+00
+           2.454369260546874E+00           2.552544030968749E+00           2.650718801390624E+00           2.748893571812499E+00           2.847068342234374E+00
+           2.945243112656249E+00           3.043417883078124E+00           3.141592653499999E+00           3.239767423921874E+00           3.337942194343749E+00
+           3.436116964765624E+00           3.534291735187499E+00           3.632466505609373E+00           3.730641276031248E+00           3.828816046453123E+00
+           3.926990816874998E+00           4.025165587296874E+00           4.123340357718749E+00           4.221515128140624E+00           4.319689898562499E+00
+           4.417864668984373E+00           4.516039439406248E+00           4.614214209828123E+00           4.712388980249998E+00           4.810563750671873E+00
+           4.908738521093748E+00           5.006913291515623E+00           5.105088061937498E+00           5.203262832359373E+00           5.301437602781248E+00
+           5.399612373203123E+00           5.497787143624998E+00           5.595961914046873E+00           5.694136684468748E+00           5.792311454890623E+00
+           5.890486225312498E+00           5.988660995734373E+00           6.086835766156248E+00           6.185010536578122E+00           6.283185306999997E+00
+           6.381360077421872E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817242E+01           1.018591635817242E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           0.000000000000000E+00           9.817477043750000E-02           1.963495408750000E-01           2.945243113125000E-01           3.926990817500000E-01
+           4.908738521875000E-01           5.890486226250000E-01           6.872233930625000E-01           7.853981635000000E-01           8.835729339375000E-01
+           9.817477043750000E-01           1.079922474812500E+00           1.178097245250000E+00           1.276272015687500E+00           1.374446786125000E+00
+           1.472621556562500E+00           1.570796327000000E+00           1.668971097437500E+00           1.767145867875000E+00           1.865320638312500E+00
+           1.963495408750000E+00           2.061670179187500E+00           2.159844949625000E+00           2.258019720062499E+00           2.356194490499999E+00
+           2.454369260937499E+00           2.552544031374999E+00           2.650718801812499E+00           2.748893572249998E+00           2.847068342687498E+00
+           2.945243113124998E+00           3.043417883562498E+00           3.141592653999997E+00           3.239767424406248E+00           3.337942194812498E+00
+           3.436116965218748E+00           3.534291735624998E+00           3.632466506031248E+00           3.730641276437498E+00           3.828816046843748E+00
+           3.926990817249998E+00           4.025165587656248E+00           4.123340358062499E+00           4.221515128468749E+00           4.319689898874999E+00
+           4.417864669281249E+00           4.516039439687499E+00           4.614214210093749E+00           4.712388980499999E+00           4.810563750906249E+00
+           4.908738521312499E+00           5.006913291718750E+00           5.105088062125000E+00           5.203262832531250E+00           5.301437602937500E+00
+           5.399612373343750E+00           5.497787143750000E+00           5.595961914156250E+00           5.694136684562500E+00           5.792311454968750E+00
+           5.890486225375001E+00           5.988660995781251E+00           6.086835766187501E+00           6.185010536593751E+00           6.283185307000001E+00
+           6.381360077406251E+00
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           0.000000000000000E+00
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655131E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635817244E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979347E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           0.000000000000000E+00           9.817477042187500E-02           1.963495408437500E-01           2.945243112656250E-01           3.926990816875000E-01
+           4.908738521093750E-01           5.890486225312500E-01           6.872233929531251E-01           7.853981633750000E-01           8.835729337968750E-01
+           9.817477042187499E-01           1.079922474640625E+00           1.178097245062500E+00           1.276272015484375E+00           1.374446785906250E+00
+           1.472621556328125E+00           1.570796326750000E+00           1.668971097171875E+00           1.767145867593749E+00           1.865320638015624E+00
+           1.963495408437499E+00           2.061670178859374E+00           2.159844949281249E+00           2.258019719703124E+00           2.356194490124999E+00
+           2.454369260546874E+00           2.552544030968749E+00           2.650718801390624E+00           2.748893571812499E+00           2.847068342234374E+00
+           2.945243112656249E+00           3.043417883078124E+00           3.141592653499999E+00           3.239767423921874E+00           3.337942194343749E+00
+           3.436116964765624E+00           3.534291735187499E+00           3.632466505609373E+00           3.730641276031248E+00           3.828816046453123E+00
+           3.926990816874998E+00           4.025165587296874E+00           4.123340357718749E+00           4.221515128140624E+00           4.319689898562499E+00
+           4.417864668984373E+00           4.516039439406248E+00           4.614214209828123E+00           4.712388980249998E+00           4.810563750671873E+00
+           4.908738521093748E+00           5.006913291515623E+00           5.105088061937498E+00           5.203262832359373E+00           5.301437602781248E+00
+           5.399612373203123E+00           5.497787143624998E+00           5.595961914046873E+00           5.694136684468748E+00           5.792311454890623E+00
+           5.890486225312498E+00           5.988660995734373E+00           6.086835766156248E+00           6.185010536578122E+00           6.283185306999997E+00
+           6.381360077421872E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           0.000000000000000E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817242E+01           1.018591635817242E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           0.000000000000000E+00
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
Index: ISOTURB_files/working_ao096_k17_fixedDt/my_submit_script_intel.sh
===================================================================
--- ISOTURB_files/working_ao096_k17_fixedDt/my_submit_script_intel.sh	(revision 0)
+++ ISOTURB_files/working_ao096_k17_fixedDt/my_submit_script_intel.sh	(revision 0)
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+#SBATCH -o IsoTurb_64_%j.out
+#SBATCH -e IsoTurb_64_%j.err
+# SBATCH -p short -n 64
+# SBATCH -p debug -n 4
+#SBATCH -p defq -n 64
+# SBATCH -N 1
+# SBATCH -n 8
+#SBATCH -D ./
+#SBATCH -J IT256
+# SBATCH --export=NONE
+#SBATCH -t 240:00:00
+# SBATCH --mem-per-cpu=1000000
+# SBATCH --array=1-16
+#SBATCH --nice=100
+
+module load intel/2013.0.028
+#source /c1/apps/intel-cluster-studio/2013.0.028/composer_xe_2013/bin/compilervars.sh intel64
+#source /c1/apps/intel-cluster-studio/2013.0.028/impi/4.1.0.024/intel64/bin/mpivars.sh
+module load openmpi/intel/64/1.7.4
+
+mpirun ./flash4
+

Property changes on: ISOTURB_files/working_ao096_k17_fixedDt/my_submit_script_intel.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: ISOTURB_files/working_ao096_k17_fixedDt/ICdata/64x64x64.res
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: ISOTURB_files/working_ao096_k17_fixedDt/ICdata/64x64x64.res
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: ISOTURB_files/working_ao096_k17_fixedDt/ICdata/64x64x64.grd
===================================================================
--- ISOTURB_files/working_ao096_k17_fixedDt/ICdata/64x64x64.grd	(revision 0)
+++ ISOTURB_files/working_ao096_k17_fixedDt/ICdata/64x64x64.grd	(revision 0)
@@ -0,0 +1,300 @@
+   1     65
+   1     65
+   1     65
+     0.1000E+01     0.1000E+01     0.1000E+01
+           0.000000000000000E+00           9.817477042187500E-02           1.963495408437500E-01           2.945243112656250E-01           3.926990816875000E-01
+           4.908738521093750E-01           5.890486225312500E-01           6.872233929531251E-01           7.853981633750000E-01           8.835729337968750E-01
+           9.817477042187499E-01           1.079922474640625E+00           1.178097245062500E+00           1.276272015484375E+00           1.374446785906250E+00
+           1.472621556328125E+00           1.570796326750000E+00           1.668971097171875E+00           1.767145867593749E+00           1.865320638015624E+00
+           1.963495408437499E+00           2.061670178859374E+00           2.159844949281249E+00           2.258019719703124E+00           2.356194490124999E+00
+           2.454369260546874E+00           2.552544030968749E+00           2.650718801390624E+00           2.748893571812499E+00           2.847068342234374E+00
+           2.945243112656249E+00           3.043417883078124E+00           3.141592653499999E+00           3.239767423921874E+00           3.337942194343749E+00
+           3.436116964765624E+00           3.534291735187499E+00           3.632466505609373E+00           3.730641276031248E+00           3.828816046453123E+00
+           3.926990816874998E+00           4.025165587296874E+00           4.123340357718749E+00           4.221515128140624E+00           4.319689898562499E+00
+           4.417864668984373E+00           4.516039439406248E+00           4.614214209828123E+00           4.712388980249998E+00           4.810563750671873E+00
+           4.908738521093748E+00           5.006913291515623E+00           5.105088061937498E+00           5.203262832359373E+00           5.301437602781248E+00
+           5.399612373203123E+00           5.497787143624998E+00           5.595961914046873E+00           5.694136684468748E+00           5.792311454890623E+00
+           5.890486225312498E+00           5.988660995734373E+00           6.086835766156248E+00           6.185010536578122E+00           6.283185306999997E+00
+           6.381360077421872E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817242E+01           1.018591635817242E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           0.000000000000000E+00           9.817477043750000E-02           1.963495408750000E-01           2.945243113125000E-01           3.926990817500000E-01
+           4.908738521875000E-01           5.890486226250000E-01           6.872233930625000E-01           7.853981635000000E-01           8.835729339375000E-01
+           9.817477043750000E-01           1.079922474812500E+00           1.178097245250000E+00           1.276272015687500E+00           1.374446786125000E+00
+           1.472621556562500E+00           1.570796327000000E+00           1.668971097437500E+00           1.767145867875000E+00           1.865320638312500E+00
+           1.963495408750000E+00           2.061670179187500E+00           2.159844949625000E+00           2.258019720062499E+00           2.356194490499999E+00
+           2.454369260937499E+00           2.552544031374999E+00           2.650718801812499E+00           2.748893572249998E+00           2.847068342687498E+00
+           2.945243113124998E+00           3.043417883562498E+00           3.141592653999997E+00           3.239767424406248E+00           3.337942194812498E+00
+           3.436116965218748E+00           3.534291735624998E+00           3.632466506031248E+00           3.730641276437498E+00           3.828816046843748E+00
+           3.926990817249998E+00           4.025165587656248E+00           4.123340358062499E+00           4.221515128468749E+00           4.319689898874999E+00
+           4.417864669281249E+00           4.516039439687499E+00           4.614214210093749E+00           4.712388980499999E+00           4.810563750906249E+00
+           4.908738521312499E+00           5.006913291718750E+00           5.105088062125000E+00           5.203262832531250E+00           5.301437602937500E+00
+           5.399612373343750E+00           5.497787143750000E+00           5.595961914156250E+00           5.694136684562500E+00           5.792311454968750E+00
+           5.890486225375001E+00           5.988660995781251E+00           6.086835766187501E+00           6.185010536593751E+00           6.283185307000001E+00
+           6.381360077406251E+00
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           0.000000000000000E+00
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655131E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635817244E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979347E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655129E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01           1.018591635655130E+01
+           1.018591635655130E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01           1.018591635655132E+01
+           1.018591635655132E+01           1.018591635655132E+01           1.018591635736188E+01           1.018591635898300E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979359E+01           1.018591635979354E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01           1.018591635979356E+01
+           1.018591635979338E+01
+           0.000000000000000E+00           9.817477042187500E-02           1.963495408437500E-01           2.945243112656250E-01           3.926990816875000E-01
+           4.908738521093750E-01           5.890486225312500E-01           6.872233929531251E-01           7.853981633750000E-01           8.835729337968750E-01
+           9.817477042187499E-01           1.079922474640625E+00           1.178097245062500E+00           1.276272015484375E+00           1.374446785906250E+00
+           1.472621556328125E+00           1.570796326750000E+00           1.668971097171875E+00           1.767145867593749E+00           1.865320638015624E+00
+           1.963495408437499E+00           2.061670178859374E+00           2.159844949281249E+00           2.258019719703124E+00           2.356194490124999E+00
+           2.454369260546874E+00           2.552544030968749E+00           2.650718801390624E+00           2.748893571812499E+00           2.847068342234374E+00
+           2.945243112656249E+00           3.043417883078124E+00           3.141592653499999E+00           3.239767423921874E+00           3.337942194343749E+00
+           3.436116964765624E+00           3.534291735187499E+00           3.632466505609373E+00           3.730641276031248E+00           3.828816046453123E+00
+           3.926990816874998E+00           4.025165587296874E+00           4.123340357718749E+00           4.221515128140624E+00           4.319689898562499E+00
+           4.417864668984373E+00           4.516039439406248E+00           4.614214209828123E+00           4.712388980249998E+00           4.810563750671873E+00
+           4.908738521093748E+00           5.006913291515623E+00           5.105088061937498E+00           5.203262832359373E+00           5.301437602781248E+00
+           5.399612373203123E+00           5.497787143624998E+00           5.595961914046873E+00           5.694136684468748E+00           5.792311454890623E+00
+           5.890486225312498E+00           5.988660995734373E+00           6.086835766156248E+00           6.185010536578122E+00           6.283185306999997E+00
+           6.381360077421872E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           0.000000000000000E+00
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817240E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817226E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817243E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817242E+01           1.018591635817242E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01           1.018591635817244E+01
+           0.000000000000000E+00
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+   1   1   1   1   1   1
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
+  65  65  65  65  65  65
Index: ISOTURB_files/working_ao096_k17_fixedDt/flash.par
===================================================================
--- ISOTURB_files/working_ao096_k17_fixedDt/flash.par	(revision 0)
+++ ISOTURB_files/working_ao096_k17_fixedDt/flash.par	(revision 0)
@@ -0,0 +1,164 @@
+# 	Runtime parameters for the Cylinder Array problem.
+gr_pmRpDivergenceFree = 1
+gr_pmRpNfieldDivf = 2
+gr_pmRpConsvFluxes = .TRUE.
+gr_pmRpConsvFluxDensities = .FALSE.
+
+# Inverse of Reynolds Number
+invRe           = 0.005
+
+# Subgrid Scale model flag (0 no sgs model, 1 sgs model)
+isgs            = 0
+
+#       Grid dimensionality and geometry
+geometry	= "cartesian"
+
+#  Parameters for forced turbulence
+sim_fbao          =   0.96
+sim_turbkin_expect =  17
+
+#       Size of computational volume
+xmin = -3.141592653589793
+xmax =  3.141592653589793
+ymin = -3.141592653589793
+ymax =  3.141592653589793
+zmin = -3.141592653589793
+zmax =  3.141592653589793
+
+
+#       Boundary conditions
+xl_boundary_type = "periodic"
+xr_boundary_type = "periodic"
+yl_boundary_type = "periodic"
+yr_boundary_type = "periodic"
+zl_boundary_type = "periodic"
+zr_boundary_type = "periodic"
+
+#      Poisson Solver Boundary Conditions
+xl_mg_boundary_type = "periodic"
+xr_mg_boundary_type = "periodic"
+yl_mg_boundary_type = "periodic"
+yr_mg_boundary_type = "periodic"
+zl_mg_boundary_type = "periodic"
+zr_mg_boundary_type = "periodic"
+
+
+#       Simulation (grid, time, I/O) parameters
+run_comment	= "Isotropic Turbulence Problem"
+log_file	= "INS_ISOTURB.log"
+basenm		= "INS_ISOTURB_"
+restart         = .false.
+#restart         = .true.
+#checkPointFileNumber = 20
+#plotFileNumber  = 200
+#particleFileNumber = 200
+nend            = 20000000
+tmax            = 100. 
+cflflg          = 0
+cfl             = 0.25
+sigma		= 0.25
+dtspec          = 0.00025
+dtinit          = 0.00025
+tstep_change_factor = 1.05
+
+#Integration Scheme:
+intschm            = 2
+
+#Plot Variables for Visit
+plot_var_1	= "pres"
+plot_var_2      = "velx"
+plot_var_3      = "vely"
+plot_var_4      = "velz"
+plot_var_5      = "omgx"
+plot_var_6      = "omgy"
+plot_var_7      = "omgz"
+  
+pfft_setupOnce  = .false.
+convertToConsvdInMeshInterp = .false.
+
+checkpointFileIntervalTime = 100.0
+checkpointFileIntervalStep = 2000
+
+plotFileIntervalTime = 100.0
+plotFileIntervalStep = 1000
+
+# Export Stats vs z timesteps:
+nstatsz = 100
+
+# Export Slice info for statistics:
+stats_slicesz_from_file=.false.
+stats_nslicesz = 16
+
+# Tecplot Slices export info:
+tecplot_nslicesx = 1
+tecplot_nslicesy = 1
+#tecplot_nslicesz = 5
+tecplot_slicesy_from_file = .false.
+
+#summaryOutputOnly=.true.
+
+
+##	AMR parameters
+nblockx	= 18
+nblocky	= 2
+nblockz	= 2
+lrefine_min	= 1
+lrefine_max     = 1
+nrefs           = 10000000
+#refine_var_1      = "pres"
+#refine_cutoff_1   = .1
+#derefine_cutoff_1 = -.1
+enableMaskedGCFill=.true.
+##	Flux Conservation for AMR
+flux_correct    = .true.
+
+# Multigrid Convergence tolerance
+# Rickers Multigrid HG:
+mg_maxResidualNorm = 1.e-10
+
+# Martin and Cartwright Multigrid:
+mgrid_npresmooth = 1
+mgrid_npossmooth = 4
+mgrid_print_norm = .true.
+mgrid_max_residual_norm = 1.e-10
+mgrid_max_vcycles = 300
+
+# BiPCGStab Parameters:
+bipcgs_max_residual_norm = 1.e-10
+bipcgs_max_cycles = 4
+bipcgs_print_norm = .true.
+
+## Force Direct solve in this level:
+#maxDirectSolveLevel=2
+
+## Pfft Parameters:
+## Use Central Finite Difference discretization operator:
+gr_pfftDiffOpDiscretize = 2
+gr_mgDiffOpDiscretize   = 2
+
+# Timers vars:
+eachProcWritesSummary = .false.
+
+#-------WARNING: ONLY FOR UNIFORM GRID !!! ------------------------
+#       The parameters below are only necessary for the Uniform Grid
+#iGridSize      = 8     #defined as nxb * iprocs
+#jGridSize      = 8     #defined as nyb * jprocs
+#kGridSize      = 1     #defined as nzb * kprocs
+iProcs          = 1     #number of procs in the i direction
+jProcs          = 8     #number of procs in the j direction
+kProcs          = 8     #number of procs in the k direction
+
+# When using UG, iProcs, jProcs and kProcs must be specified.
+# These are the processors along each of the dimensions
+# FIXEDBLOCKSIZE mode ::
+#       When using fixed blocksize, iGridSize etc are redundant in
+#       runtime parameters. These quantities are calculated as 
+#       iGridSize = NXB*iprocs
+#       jGridSize = NYB*jprocs
+#       kGridSize = NZB*kprocs
+# NONFIXEDBLOCKSIZE mode ::
+#       iGridSize etc must be specified. They constitute the global
+#       number of grid points in the physical domain without taking 
+#       the guard cell into account. The local blocksize is calculated
+#       as iGridSize/iprocs  etc.
+ 
Index: ISOTURB_files/flash.par
===================================================================
--- ISOTURB_files/flash.par	(revision 0)
+++ ISOTURB_files/flash.par	(revision 0)
@@ -0,0 +1,160 @@
+# 	Runtime parameters for the Cylinder Array problem.
+gr_pmRpDivergenceFree = 1
+gr_pmRpNfieldDivf = 2
+gr_pmRpConsvFluxes = .TRUE.
+gr_pmRpConsvFluxDensities = .FALSE.
+
+# Inverse of Reynolds Number
+invRe           = 0.001
+
+# Subgrid Scale model flag (0 no sgs model, 1 sgs model)
+isgs            = 0
+
+#       Grid dimensionality and geometry
+geometry	= "cartesian"
+
+#       Size of computational volume
+xmin = -3.141592653589793
+xmax =  3.141592653589793
+ymin = -3.141592653589793
+ymax =  3.141592653589793
+zmin = -3.141592653589793
+zmax =  3.141592653589793
+
+
+#       Boundary conditions
+xl_boundary_type = "periodic"
+xr_boundary_type = "periodic"
+yl_boundary_type = "periodic"
+yr_boundary_type = "periodic"
+zl_boundary_type = "periodic"
+zr_boundary_type = "periodic"
+
+#      Poisson Solver Boundary Conditions
+xl_mg_boundary_type = "periodic"
+xr_mg_boundary_type = "periodic"
+yl_mg_boundary_type = "periodic"
+yr_mg_boundary_type = "periodic"
+zl_mg_boundary_type = "periodic"
+zr_mg_boundary_type = "periodic"
+
+
+#       Simulation (grid, time, I/O) parameters
+run_comment	= "Isotropic Turbulence Problem"
+log_file	= "INS_ISOTURB.log"
+basenm		= "INS_ISOTURB_"
+restart         = .false.
+#restart         = .true.
+#checkPointFileNumber=2
+#plotFileNumber  = 3
+#particleFileNumber = 3
+nend            = 500000
+tmax            = 500. 
+cflflg          = 0
+cfl             = 0.3
+sigma		= 0.2
+dtspec          = 0.001
+dtinit          = 0.001
+tstep_change_factor = 1.05
+
+#Integration Scheme:
+intschm            = 2
+
+#Plot Variables for Visit
+plot_var_1	= "pres"
+plot_var_2      = "velx"
+plot_var_3      = "vely"
+plot_var_4      = "velz"
+plot_var_5      = "omgx"
+plot_var_6      = "omgy"
+plot_var_7      = "omgz"
+  
+pfft_setupOnce  = .false.
+convertToConsvdInMeshInterp = .false.
+
+checkpointFileIntervalTime = 2500.00
+checkpointFileIntervalStep = 20000
+
+plotFileIntervalTime = 2500.00
+plotFileIntervalStep = 5000
+
+# Export Stats vs z timesteps:
+nstatsz = 5000
+
+# Export Slice info for statistics:
+stats_slicesz_from_file=.false.
+stats_nslicesz = 16
+
+# Tecplot Slices export info:
+tecplot_nslicesx = 1
+tecplot_nslicesy = 1
+#tecplot_nslicesz = 5
+tecplot_slicesy_from_file = .false.
+
+#summaryOutputOnly=.true.
+
+
+##	AMR parameters
+nblockx	= 18
+nblocky	= 2
+nblockz	= 2
+lrefine_min	= 1
+lrefine_max     = 1
+nrefs           = 10000000
+#refine_var_1      = "pres"
+#refine_cutoff_1   = .1
+#derefine_cutoff_1 = -.1
+enableMaskedGCFill=.true.
+##	Flux Conservation for AMR
+flux_correct    = .true.
+
+# Multigrid Convergence tolerance
+# Rickers Multigrid HG:
+mg_maxResidualNorm = 1.e-10
+
+# Martin and Cartwright Multigrid:
+mgrid_npresmooth = 1
+mgrid_npossmooth = 4
+mgrid_print_norm = .true.
+mgrid_max_residual_norm = 1.e-10
+mgrid_max_vcycles = 300
+
+# BiPCGStab Parameters:
+bipcgs_max_residual_norm = 1.e-10
+bipcgs_max_cycles = 4
+bipcgs_print_norm = .true.
+
+## Force Direct solve in this level:
+#maxDirectSolveLevel=2
+
+## Pfft Parameters:
+## Use Central Finite Difference discretization operator:
+gr_pfftDiffOpDiscretize = 2
+gr_mgDiffOpDiscretize   = 2
+
+# Timers vars:
+eachProcWritesSummary = .false.
+
+#-------WARNING: ONLY FOR UNIFORM GRID !!! ------------------------
+#       The parameters below are only necessary for the Uniform Grid
+#iGridSize      = 8     #defined as nxb * iprocs
+#jGridSize      = 8     #defined as nyb * jprocs
+#kGridSize      = 1     #defined as nzb * kprocs
+iProcs          = 1     #number of procs in the i direction
+jProcs          = 4     #number of procs in the j direction
+kProcs          = 4     #number of procs in the k direction
+
+# When using UG, iProcs, jProcs and kProcs must be specified.
+# These are the processors along each of the dimensions
+# FIXEDBLOCKSIZE mode ::
+#       When using fixed blocksize, iGridSize etc are redundant in
+#       runtime parameters. These quantities are calculated as 
+#       iGridSize = NXB*iprocs
+#       jGridSize = NYB*jprocs
+#       kGridSize = NZB*kprocs
+# NONFIXEDBLOCKSIZE mode ::
+#       iGridSize etc must be specified. They constitute the global
+#       number of grid points in the physical domain without taking 
+#       the guard cell into account. The local blocksize is calculated
+#       as iGridSize/iprocs  etc.
+ 
Index: Simulation_data.F90
===================================================================
--- Simulation_data.F90	(revision 0)
+++ Simulation_data.F90	(revision 0)
@@ -0,0 +1,30 @@
+!!****if* source/Simulation/SimulationMain/INavierStokes/3D/ChannelLam/Simulation_data
+!!
+!! NAME
+!!
+!!  Simulation_data
+!!
+!! SYNOPSIS
+!!
+!!  Simulation_data()
+!!
+!! DESCRIPTION
+!!
+!!  Stores the local data for Simulation setup: INS-iso-turb
+!!
+!!***
+
+module Simulation_data
+
+  implicit none
+
+#include "constants.h"
+
+  !! *** Runtime Parameters *** !!
+  real, save    :: sim_xMin, sim_xMax, sim_yMin, sim_yMax, sim_zMin, sim_zMax
+  logical, save :: sim_gCell
+  
+  integer, save :: sim_meshMe
+  real, save :: sim_turbkin_expect, sim_fbao, sim_scaleForce
+
+end module Simulation_data
Index: Makefile
===================================================================
--- Makefile	(revision 0)
+++ Makefile	(revision 0)
@@ -0,0 +1,6 @@
+Simulation += Simulation_data.o Simulation_init.o Simulation_initBlock.o outtotecplot.o interpvars_face.o ins_turbstats.o ins_turbstats_z.o ins_exportslices_z.o ins_substractmeanvel.o ins_substractmeanvel_z.o ins_exportBlock.o 
+Simulation_init.o : Simulation_data.o
+Simulation_initBlock.o : Simulation_data.o 
+
+
+#  PresDp3P.o fftpack.o comf.f
Index: flash.par
===================================================================
--- flash.par	(revision 0)
+++ flash.par	(revision 0)
@@ -0,0 +1,160 @@
+# 	Runtime parameters for the Cylinder Array problem.
+gr_pmRpDivergenceFree = 1
+gr_pmRpNfieldDivf = 2
+gr_pmRpConsvFluxes = .TRUE.
+gr_pmRpConsvFluxDensities = .FALSE.
+
+# Inverse of Reynolds Number
+invRe           = 0.001
+
+# Subgrid Scale model flag (0 no sgs model, 1 sgs model)
+isgs            = 0
+
+#       Grid dimensionality and geometry
+geometry	= "cartesian"
+
+#       Size of computational volume
+xmin = -3.141592653589793
+xmax =  3.141592653589793
+ymin = -3.141592653589793
+ymax =  3.141592653589793
+zmin = -3.141592653589793
+zmax =  3.141592653589793
+
+
+#       Boundary conditions
+xl_boundary_type = "periodic"
+xr_boundary_type = "periodic"
+yl_boundary_type = "periodic"
+yr_boundary_type = "periodic"
+zl_boundary_type = "periodic"
+zr_boundary_type = "periodic"
+
+#      Poisson Solver Boundary Conditions
+xl_mg_boundary_type = "periodic"
+xr_mg_boundary_type = "periodic"
+yl_mg_boundary_type = "periodic"
+yr_mg_boundary_type = "periodic"
+zl_mg_boundary_type = "periodic"
+zr_mg_boundary_type = "periodic"
+
+
+#       Simulation (grid, time, I/O) parameters
+run_comment	= "Isotropic Turbulence Problem"
+log_file	= "INS_ISOTURB.log"
+basenm		= "INS_ISOTURB_"
+restart         = .false.
+#restart         = .true.
+#checkPointFileNumber=2
+#plotFileNumber  = 3
+#particleFileNumber = 3
+nend            = 500000
+tmax            = 500. 
+cflflg          = 0
+cfl             = 0.3
+sigma		= 0.2
+dtspec          = 0.001
+dtinit          = 0.001
+tstep_change_factor = 1.05
+
+#Integration Scheme:
+intschm            = 2
+
+#Plot Variables for Visit
+plot_var_1	= "pres"
+plot_var_2      = "velx"
+plot_var_3      = "vely"
+plot_var_4      = "velz"
+plot_var_5      = "omgx"
+plot_var_6      = "omgy"
+plot_var_7      = "omgz"
+  
+pfft_setupOnce  = .false.
+convertToConsvdInMeshInterp = .false.
+
+checkpointFileIntervalTime = 2500.00
+checkpointFileIntervalStep = 20000
+
+plotFileIntervalTime = 2500.00
+plotFileIntervalStep = 5000
+
+# Export Stats vs z timesteps:
+nstatsz = 5000
+
+# Export Slice info for statistics:
+stats_slicesz_from_file=.false.
+stats_nslicesz = 16
+
+# Tecplot Slices export info:
+tecplot_nslicesx = 1
+tecplot_nslicesy = 1
+#tecplot_nslicesz = 5
+tecplot_slicesy_from_file = .false.
+
+#summaryOutputOnly=.true.
+
+
+##	AMR parameters
+nblockx	= 18
+nblocky	= 2
+nblockz	= 2
+lrefine_min	= 1
+lrefine_max     = 1
+nrefs           = 10000000
+#refine_var_1      = "pres"
+#refine_cutoff_1   = .1
+#derefine_cutoff_1 = -.1
+enableMaskedGCFill=.true.
+##	Flux Conservation for AMR
+flux_correct    = .true.
+
+# Multigrid Convergence tolerance
+# Rickers Multigrid HG:
+mg_maxResidualNorm = 1.e-10
+
+# Martin and Cartwright Multigrid:
+mgrid_npresmooth = 1
+mgrid_npossmooth = 4
+mgrid_print_norm = .true.
+mgrid_max_residual_norm = 1.e-10
+mgrid_max_vcycles = 300
+
+# BiPCGStab Parameters:
+bipcgs_max_residual_norm = 1.e-10
+bipcgs_max_cycles = 4
+bipcgs_print_norm = .true.
+
+## Force Direct solve in this level:
+#maxDirectSolveLevel=2
+
+## Pfft Parameters:
+## Use Central Finite Difference discretization operator:
+gr_pfftDiffOpDiscretize = 2
+gr_mgDiffOpDiscretize   = 2
+
+# Timers vars:
+eachProcWritesSummary = .false.
+
+#-------WARNING: ONLY FOR UNIFORM GRID !!! ------------------------
+#       The parameters below are only necessary for the Uniform Grid
+#iGridSize      = 8     #defined as nxb * iprocs
+#jGridSize      = 8     #defined as nyb * jprocs
+#kGridSize      = 1     #defined as nzb * kprocs
+iProcs          = 4     #number of procs in the i direction
+jProcs          = 4     #number of procs in the j direction
+kProcs          = 4     #number of procs in the k direction
+
+# When using UG, iProcs, jProcs and kProcs must be specified.
+# These are the processors along each of the dimensions
+# FIXEDBLOCKSIZE mode ::
+#       When using fixed blocksize, iGridSize etc are redundant in
+#       runtime parameters. These quantities are calculated as 
+#       iGridSize = NXB*iprocs
+#       jGridSize = NYB*jprocs
+#       kGridSize = NZB*kprocs
+# NONFIXEDBLOCKSIZE mode ::
+#       iGridSize etc must be specified. They constitute the global
+#       number of grid points in the physical domain without taking 
+#       the guard cell into account. The local blocksize is calculated
+#       as iGridSize/iprocs  etc.
+ 
