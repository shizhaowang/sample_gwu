!!****if* source/Simulation/SimulationMain/Flash2Convert/io_readData
!!
!! NAME
!!
!!  io_readData
!!
!!
!! SYNOPSIS
!!
!!  io_readData() 
!!              integer(in) :: numProcs)
!!
!!
!! DESCRIPTION
!!
!!  This version is meant for use with reading in Flash2 files only.
!!  Files should be converted and output as Flash 3 checkpoints before being 
!!  used to start a Flash 3 run.  The metadata generated by Flash 3's write
!!  routines will not be defined by this routine as it may not exist in Flash 2.
!!
!!  This is the reading counterpart to io_writeData.  It reads an HDF5
!!  file and distributes it to the processors to restart a simulation.
!!
!!  All reading is done using parallel HDF5 -- no explicit data movement
!!  is used.
!!
!!
!! ARGUMENTS
!!   myPE : current processor number
!!   numProcs : number of processors in the simulation
!!
!!***




subroutine io_readData(myPE, numProcs)



  use Grid_data, ONLY : gr_gid, gr_globalNumBlocks, gr_nToLeft, &
       gr_globalOffset
  use Driver_interface, ONLY : Driver_abortFlash
  use Logfile_interface, ONLY : Logfile_stamp
  use Grid_interface, ONLY : Grid_putLocalNumBlks
  use IO_data
!!$  use IO_data, ONLY : io_baseName, io_checkpointFileNumber, &
!!$       io_realParmNames, io_realParmValues, io_numRealParms, &
!!$       io_intParmNames, io_intParmValues, io_numIntParms, &
!!$       io_logParmNames, io_logParmValues, io_numLogParms, &
!!$       io_strParmNames, io_strParmValues, io_numStrParms, &
!!$       io_realScalarNames, io_realScalarValues, io_numRealScalars, &
!!$       io_intScalarNames, io_intScalarValues, io_numIntScalars, &
!!$       io_logScalarNames, io_logScalarValues, io_numLogScalars, &
!!$       io_strScalarNames, io_strScalarValues, io_numStrScalars, &
!!$       io_logToIntScalarValues, io_logToIntParmValues, io_unklabels, &
!!$       io_ilo, io_ihi, io_jlo, io_jhi, io_klo, io_khi, &
!!$       io_outputSplitNum, io_comm, io_chkptFileID, io_chkGuardCells
  use IO_interface, ONLY : IO_getScalar, IO_setScalar, IO_getPrevScalar

  use tree

  use physicaldata, ONLY : unk


  implicit none

#include "mpif.h"
#include "constants.h"
#include "Flash.h"





  integer, intent(in) :: myPE, numProcs

  integer :: localNumBlocks, ngid
  integer :: alocalNumBlocks

  
  character (len=4) :: fnumStr
  character (len=MAX_STRING_LENGTH) :: filename
  character(len=MAX_STRING_LENGTH), save, allocatable, dimension(:,:) :: strBuff


  integer :: blockID, procBlocks, ierr

  integer :: i, lb, j, xx, yy, div, alnblocks

  integer, allocatable :: procnumber(:) !dimension(localNumBlocks)
  
  integer :: realGlobalNumBlocks
  real :: unkBufGC(1,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC,MAXBLOCKS)
  real,allocatable :: unkBuf(:,:,:,:,:)

  !For reading in scalar information from flash2 files 
  !(scalar list non-existant)
  integer :: tot_blocks, tnstep, parentID, map_idx, nbegin, numFlash2Vars
  real :: simtimet, dtt, redshiftt
  character (len=4), allocatable :: flash2_unk_name(:,:)
  integer, allocatable :: flash2_to_flash3_map(:)
  integer, allocatable :: recon_gid(:,:)
  !allocate(gr_nToLeft(0:numProcs-1))

   
  !allocate(gr_gid(nfaces+nchild+1, MAXBLOCKS))

  

  call io_getOutputName(io_checkpointFileNumber, "f2_hdf5", "_chk_", filename,.false.)
  
print *,filename


  !generate a group of old names for reading in flash2 variables.
  OPEN(UNIT=10, FILE='flash2vars', status='OLD')
  READ(10, '(I)'), numFlash2Vars
  allocate(flash2_unk_name(numFlash2Vars, 2))
  allocate(flash2_to_flash3_map(numFlash2Vars))
  do i = 1,numFlash2Vars
    READ(10, '((A4)," ",(A4))'), flash2_unk_name(i,1), flash2_unk_name(i, 2)
    !print*, flash2_unk_name(i,1),' ',flash2_unk_name(i,2)
  end do
  CLOSE(10)

  call io_h5open_file_for_read(io_chkptFileID, filename, io_comm, io_outputSplitNum)

  if (myPE == MASTER_PE) then
       allocate (strBuff(2,2))
       print *, 'file: ', trim(filename), ' opened for restart'
       write (strBuff(1,1), "(A)") "type"
       write (strBuff(1,2), "(A)") "checkpoint"
       write (strBuff(2,1), "(A)") "name"
       write (strBuff(2,2), "(A)") trim(filename)
       call Logfile_stamp( strBuff, 2, 2, "[io_readData]")
  end if
  if (allocated(strBuff)) deallocate(strBuff)
  
  !print *,flash2_unk_name(:,:) 
  !print *,io_unklabels(:)
  !create a map index between flash2 and flash3 names
  do i = 1, numFlash2Vars
    if(flash2_unk_name(i,2) == '?   ') then !there is no mapping from flash2 to flash3
       flash2_to_flash3_map(i) = -1
   !    print *, 'flash2_unk_name not found in flash3 = ', flash2_unk_name(i,1)
    else
     do j = UNK_VARS_BEGIN, UNK_VARS_END
    
      if(flash2_unk_name(i,2) == io_unklabels(j)) then
    flash2_to_flash3_map(i) = j
    print *, ' name ', flash2_unk_name(i,1),' found: idx = ',j
    exit
      end if
     end do
    end if
  end do
 
  !read in the total number of blocks, time, and timestep
  call io_h5read_header(myPE, &
            io_chkptFileID, &
                        io_unklabels, &
                        io_outputSplitNum)
 
 
  call io_prepareListsRead()

  print *,io_numRealParmsPrev

  call io_h5read_runtime_parameters(io_chkptFileID, &
       io_numRealParmsPrev, &
       io_realParmNamesPrev, &
       io_realParmValuesPrev, &
       io_numIntParmsPrev, &
       io_intParmNamesPrev, &
       io_intParmValuesPrev, &
       io_numStrParmsPrev, &
       io_strParmNamesPrev, &
       io_strParmValuesPrev, &
       io_numLogParmsPrev, &
       io_logParmNamesPrev, &
       io_logToIntParmValuesPrev, &
       io_outputSplitNum)

    call io_finalizeListsRead(myPE, numProcs)
  
  !call io_h5read_scalars(io_chkptFileID, &
   !    io_numRealScalars, &
    !   io_realScalarNames, &
     !  io_realScalarValues, &
  !     io_numIntScalars, &
   !    io_intScalarNames, &
    !   io_intScalarValues, &
     !  io_numStrScalars, &
!       io_strScalarNames, &
!       io_strScalarValues, &
 !      io_numLogScalars, &
  !     io_logScalarNames, &
   !    io_logToIntScalarValues, &
    !io_outputSplitNum)

! Fake a list for scalars.

!call MPI_BARRIER(MPI_COMM_WORLD, ierr)
 !call Driver_abortFlash("Debug Abort.")

    call io_h5read_f2header(myPE, &
                   io_chkptFileID, &
                   tot_blocks, &
                   simtimet, &
                   dtt, &
                   redshiftt, &
                   tnstep)
  
 

    !call io_simBuildScalars
    call io_setPrevScalarInt('globalNumBlocks', tot_blocks);
    call io_setPrevScalarReal('time', simtimet)
    call io_setPrevScalarReal('dt', dtt)
    call io_setPrevScalarReal('redshift',redshiftt)
    call io_setPrevScalarInt('nstep',tnstep)
    !print *, dtt

    !DEV: figure out how to make these make sense if needed.
    call io_setPrevScalarReal('nextCheckpointTime', 0.0)
    call io_setPrevScalarReal('nextPlotFileTime', 0.0)
    !call IO_getPrevScalar('nextCheckpointTime', dtt)
    !print *, dtt
    call IO_setScalar("nextCheckpointTime", 0.0)
    print *,' PrevScalarsSet'
    !call Driver_abortFlash("DEBUG ABORT")

    if(tnstep .GT. 0) then
    nbegin = tnstep + 1
    else
    nbegin = tnstep
    end if
    call io_setPrevScalarInt("nbegin", nbegin)
!end scalar translation


  call IO_getScalar("globalNumBlocks", gr_globalNumBlocks)

  !---------------------------------------------------------------------------
  ! compute the number of blocks on each processor -- this will be used to
  ! get the offset into the file for the parallel read
  !---------------------------------------------------------------------------
    
 
!!$  
!!$  if(io_outputSplitNum == numProcs) then
!!$
!!$     gr_globalOffset = 0
!!$
!!$     localNumBlocks = gr_globalNumBlocks
!!$
!!$     call MPI_AllReduce(localNumBlocks, realGlobalNumBlocks, 1, MPI_INTEGER, &
!!$          MPI_SUM, MPI_COMM_WORLD, ierr)
!!$
!!$
!!$     alnblocks = int(realGlobalNumBlocks/numProcs) + 1
!!$     ! figure out the excess blocks
!!$     yy = (numProcs*alnblocks) - realGlobalNumBlocks
!!$     xx = numProcs - yy
!!$
!!$     print *, "localNumBlocks = ", localNumBlocks, myPE
!!$     print *, "realGlobalNumBlocks = ", realGlobalNumBlocks, myPE
!!$
!!$
!!$  else

  ! compute the approximate number of blocks per processor
  alnblocks = int(gr_globalNumBlocks/numProcs) + 1
  
  ! check for error -- if the number of blocks we want to put on each
  ! processor is greater than maxblocks, then abort
  if (alnblocks .GT. MAXBLOCKS) then
     
     print *
     print *, '********** ERROR in READ_DATA ************'
     print *
     print *,' Number of blocks per processor exceeds maxblocks.'
     print *,' Suggest you reset maxblocks to a larger number or'
     print *,' run on a larger number of processors.'
     print *,' globalNumBlocks, numProcs = ', gr_globalNumBlocks, numProcs
     print *
     
     call Driver_abortFlash('[io_readData] ERROR: num blocks per proc exceeds maxblocks')
     
  end if
  
  ! figure out the excess blocks
  yy = (numProcs*alnblocks) - gr_globalNumBlocks
  xx = numProcs - yy
  
  ! loop over all the processor numbers and figure out how many blocks are
  ! stored to the left of the processor -- this is a little tricky
  
  gr_nToLeft(0) = 0
  
  do i = 0, numProcs - 2
     if (i .LT. xx) then
        procBlocks = alnblocks
     else
        procBlocks = alnblocks - 1
     endif
     
     if (alnblocks .EQ. 0) then
        if (i .LT. gr_globalNumBlocks) then
           procBlocks = 1
        else
           procBlocks = 0
        end if
     end if
     
     ! we have the number of blocks on proc i, the number of blocks on i+1 is
     ! the number of blocks on i + the number of blocks left of i
     if (i .EQ. 0) then
        gr_nToLeft(i+1) = procBlocks
     else
        gr_nToLeft(i+1) = procBlocks + gr_nToLeft(i)
     endif
  enddo
  
  ! figure out how many blocks are on the current proc.
  if (myPE < xx) then
     localNumBlocks = alnblocks
  else
     localNumBlocks = alnblocks - 1
  endif
  
  if (alnblocks .EQ. 0) then
     if (myPE < gr_globalNumBlocks) then
        localNumBlocks = 1
     else
        localNumBlocks = 0
     end if
  end if
  
  ! compute the offset into the dataspace in the HDF5 file
  gr_globalOffset = gr_nToLeft(myPE)
  


  call Grid_putLocalNumBlks(localNumBlocks)



  ! refinement level
  call io_h5read_lrefine(io_chkptFileID, &
                       lrefine, &
                       localNumBlocks, &
                       gr_globalNumBlocks, &
                       gr_globalOffset)



#ifdef FLASH_GRID_PARAMESH3OR4

  !additional data structures required by PM3
  !which child definitely needed for restart
  !bflags there for completeness
  !These did not exist in Flash 2!
  
  ! which child -- have to determine by tree traversal
  !call io_h5read_which_child(io_chkptFileID, &
   !                    which_child, &
    !                   localNumBlocks, &
     !                  gr_globalNumBlocks, &
      !                 gr_globalOffset)

  ! bflags
  !call io_h5read_bflags(io_chkptFileID, &
  !                 bflags, &
   !                localNumBlocks, &
    !               gr_globalNumBlocks, &
     !              gr_globalOffset)
    
    !bflags not used by FLASH2.  Set to -1 (appears to be a default value)
    bflags(:,:) = -1
    !finding which child from gid table: must do by tree traversal?
    !naive version: most likely trouble.
    
    !allocate an array the size of the full gid in the file for 
    !which child reconstruction
    allocate(recon_gid(nfaces+nchild+1, tot_blocks))  

    ! global id : must be here since we need gid table to reconstruct which child.
    call io_h5read_gid(io_chkptFileID, &
                   recon_gid, &
                   gr_globalNumBlocks, &
                   gr_globalNumBlocks, &
                   0)

    !for each in gid
    print *, 'global offset: ', gr_globalOffset, ' nlb ', localNumBlocks
    print *, gr_globalNumBlocks
    print *, ngid  
    ngid = nfaces + 1
    do blockID = gr_globalOffset+1, (localNumBlocks + gr_globalOffset)
    print * , 'checking blockID = ', blockID
    !if no parent, then move to next
    if(recon_gid(ngid,blockID) .EQ. -1) then
        which_child(blockID-gr_globalOffset) = -1
       !  print *, 'on mype: ', mype, ' i ' , -1,' for blkID ', blockID
        CONTINUE
    else
     parentID = recon_gid(ngid, blockID)
     do i = 1 ,nchild
      
      if(recon_gid((ngid + i), parentID) .EQ. blockID) then
         which_child(blockID-gr_globalOffset) = i
print *, 'on mype: ', mype, ' parentID ',parentID,' for blkID ', blockID, 'i',i
         EXIT
       end if
     end do
    end if
    end do
    print *, 'WHICH CHILD OK'
    deallocate(recon_gid)
#endif


  ! node type
  call io_h5read_nodetype(io_chkptFileID, &
                        nodetype, &
                        localNumBlocks, &
                        gr_globalNumBlocks, &
                        gr_globalOffset)

  ! coordinates
  call io_h5read_coords(io_chkptFileID, &
                     maxblocks_tr, &
                     coord, &
                     localNumBlocks, &
                     gr_globalNumBlocks, &
                     gr_globalOffset)
 
 ! global id : must reset to keep other code consistient.
  call io_h5read_gid(io_chkptFileID, &
                   gr_gid, &
                   localNumBlocks, &
                   gr_globalNumBlocks, &
                   gr_globalOffset)

  ! block size
  call io_h5read_blksize(io_chkptFileID, &
                    maxblocks_tr, &
                    bsize, &
                    localNumBlocks, &
                    gr_globalNumBlocks, &
                    gr_globalOffset)
  
  ! bounding box
  call io_h5read_bndbox(io_chkptFileID, &
                       maxblocks_tr, &
                       bnd_box, &
                       localNumBlocks, &
                       gr_globalNumBlocks, &
                       gr_globalOffset)

  allocate(unkBuf(1, NXB, NYB, NZB, MAXBLOCKS))
  do i = 1,numFlash2Vars

  map_idx = flash2_to_flash3_map(i) 
  if(map_idx /= -1) then
     
     if(io_chkGuardCells) then
        call io_h5read_unknowns(io_chkptFileID, &
             GRID_IHI_GC, &
             GRID_JHI_GC, &
             GRID_KHI_GC, &
             unkBufGC, &
             flash2_unk_name(i,1), &
             localNumBlocks, &
             gr_globalNumBlocks,  &
             gr_globalOffset)
       
        unk(map_idx,:,:,:,1:MAXBLOCKS) = & 
             unkBufGC(1,:,:,:,1:MAXBLOCKS)


     else

print *, 'if OK'
print *, map_idx, flash2_unk_name(i,1)
        call io_h5read_unknowns(io_chkptFileID, &
             NXB, &
             NYB, &
             NZB, &
             unkBuf, &
             flash2_unk_name(i,1), &
             localNumBlocks, &
             gr_globalNumBlocks,  &
             gr_globalOffset)
        
       print *, 'read unknowns OK'
        
        unk(map_idx,io_ilo:io_ihi, io_jlo:io_jhi, io_klo:io_khi,1:MAXBLOCKS) = & 
             unkBuf(1,1:NXB,1:NYB,1:NZB,1:MAXBLOCKS)
        
     end if
    print *, 'unk assigned'
    end if

  enddo

  deallocate(unkBuf)
  
  
  call mpi_barrier (MPI_COMM_WORLD, ierr)
  if (myPE == MASTER_PE) &
    print *, 'read_data:  read ', gr_globalNumBlocks, ' blocks.'


  if (myPE == MASTER_PE) then
     allocate (strBuff(2, 2))
     write (strBuff(1,1), "(A)") "type"
     write (strBuff(1,2), "(A)") "checkpoint"
     write (strBuff(2,1), "(A)") "name"
     write (strBuff(2,2), "(A)") trim(filename)
     call Logfile_stamp( strBuff, 2, 2, "[io_readData] file_closed")
     if (allocated(strBuff)) deallocate(strBuff)
  end if

  div = xx*alnblocks



!!$  
!!$  if(io_outputSplitNum == numProcs) then
!!$     call IO_setScalar("globalNumBlocks", realGlobalNumBlocks)
!!$  end if
!!$
!!$
!!$
!!$  print *, "alnblocks, xx, yy, div", alnblocks, xx, yy, div, myPE

!-----------------------------------------------------------------------------
! build the tree information from the gid array and the number of blocks
! on each processor
!-----------------------------------------------------------------------------

  do blockID = 1,localNumBlocks

! neighbor data
     ngid = 0
     do j = 1,nfaces
        ngid = ngid + 1

        if (gr_gid(ngid,blockID).gt.0) then

           if (gr_gid(ngid,blockID).le.div) then
              neigh(2,j,blockID) = int((gr_gid(ngid,blockID)-1)/alnblocks)

              if (neigh(2,j,blockID).gt.numProcs-1)  &
                   neigh(2,j,blockID) = numProcs - 1

              neigh(1,j,blockID) = gr_gid(ngid,blockID) -  &
                   (alnblocks*neigh(2,j,blockID))
           else
              neigh(2,j,blockID) = &
                   int((gr_gid(ngid,blockID)-1-div)/(alnblocks-1)) + xx

              if (neigh(2,j,blockID).gt.numProcs-1)  &
                   neigh(2,j,blockID) = numProcs - 1

              neigh(1,j,blockID) = gr_gid(ngid,blockID) - div - &
                   ((alnblocks-1)*(neigh(2,j,blockID)-xx))
           end if
        else
           neigh(1,j,blockID) = gr_gid(ngid,blockID)
           neigh(2,j,blockID) = gr_gid(ngid,blockID)
        end if
     end do

! parent data
     ngid = ngid + 1
     if (gr_gid(ngid,blockID).gt.0) then
        if (gr_gid(ngid,blockID).le.div) then
           parent(2,blockID) = int((gr_gid(ngid,blockID)-1)/alnblocks)
           if (parent(2,blockID).gt.numProcs-1)  &
                parent(2,blockID) = numProcs - 1
           parent(1,blockID) = gr_gid(ngid,blockID) -  &
                (alnblocks*parent(2,blockID))
        else
           parent(2,blockID) = &
                int((gr_gid(ngid,blockID)-1-div)/(alnblocks-1)) + xx
           if (parent(2,blockID).gt.numProcs-1)  &
                parent(2,blockID) = numProcs - 1
           parent(1,blockID) = gr_gid(ngid,blockID) - div - &
                ((alnblocks-1)*(parent(2,blockID)-xx))
        end if
     else
        parent(1,blockID) = gr_gid(ngid,blockID)
        parent(2,blockID) = gr_gid(ngid,blockID)
     end if

! children data
     do j = 1,nchild
        ngid = ngid + 1
        if (gr_gid(ngid,blockID).gt.0) then
           if (gr_gid(ngid,blockID).le.div) then
              child(2,j,blockID) = int((gr_gid(ngid,blockID)-1)/alnblocks)
              if (child(2,j,blockID).gt.numProcs-1)  &
                   child(2,j,blockID) = numProcs - 1
              child(1,j,blockID) = gr_gid(ngid,blockID) -  &
                   (alnblocks*child(2,j,blockID))
           else
              child(2,j,blockID) = &
                   int((gr_gid(ngid,blockID)-1-div)/(alnblocks-1)) + xx
              if (child(2,j,blockID).gt.numProcs-1)  &
                   child(2,j,blockID) = numProcs - 1
              child(1,j,blockID) = gr_gid(ngid,blockID) - div - &
                   ((alnblocks-1)*(child(2,j,blockID)-xx))
           end if
        else
           child(1,j,blockID) = gr_gid(ngid,blockID)
           child(2,j,blockID) = gr_gid(ngid,blockID)
        end if
     end do

  end do

  deallocate (flash2_unk_name)
  deallocate (flash2_to_flash3_map)
  call MPI_BARRIER (MPI_COMM_WORLD, ierr)

  if (myPE == MASTER_PE) &
    print *, 'io_readData:  finished reading input file.'
    
  !call io_writeCheckpoint(myPE, numProcs)
  return

end subroutine io_readData
